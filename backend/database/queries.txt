Zum Updaten von Labels:
^^^^^^^^^^^^^^^^^^^^^^^^
Hier: Techniques von json hinzufügen

CALL apoc.load.json("catalogue_entries_0.json") YIELD value
WITH value.ID AS jsonID, value.Type AS jsonType
LIMIT 2000
MATCH (n:CatalogueEntry)
WHERE n.id = toString(jsonID)
SET n.tech = jsonType



Zum Anzeigen von sharedExhibitions:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
// Step 1: Collect Exhibition IDs for each artist, potentially limit to relevant artists
MATCH (a:Artist)-[:EXHIBITED]->(e:Exhibition)
WITH a, COLLECT(e.id) AS a_exhibitions
ORDER BY SIZE(a_exhibitions) DESC LIMIT 100 // Limit to top 100 artists based on exhibition count

// Step 2: Repeat collection for all artists, then perform pair comparison
MATCH (b:Artist)-[:EXHIBITED]->(f:Exhibition)
WITH a, a_exhibitions, b, COLLECT(f.id) AS b_exhibitions
WHERE a <> b AND a.id < b.id // Ensure unique pairs and avoid self-comparison

// Step 3: Calculate the intersection of their exhibition lists, use native functions if APOC not available
WITH a, b, [x IN a_exhibitions WHERE x IN b_exhibitions] AS shared_exhibitions
RETURN a.firstname AS Artist1, b.firstname AS Artist2, SIZE(shared_exhibitions) AS SharedExhibitionCount
ORDER BY SharedExhibitionCount DESC
LIMIT 20


Zum Einfügen der Properties in exhibited_with:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

SharedExhibitions:
MATCH (a:Artist)-[:EXHIBITED]->(e:Exhibition)
WITH a, COLLECT(e.id) AS a_exhibitions
ORDER BY SIZE(a_exhibitions) DESC LIMIT 100 
// Step 2: Repeat collection for all artists, then perform pair comparison
MATCH (b:Artist)-[:EXHIBITED]->(f:Exhibition)
WITH a, a_exhibitions, b, COLLECT(f.id) AS b_exhibitions
WHERE a <> b AND a.id < b.id // Ensure unique pairs and avoid self-comparison

// Step 3: Calculate the intersection of their exhibition lists
WITH a, b, [x IN a_exhibitions WHERE x IN b_exhibitions] AS shared_exhibitions

// Step 4: Create or update EXHIBITED_WITH relationships with shared exhibition count for all pairs
FOREACH (ignored IN CASE WHEN SIZE(shared_exhibitions) > 0 THEN [1] ELSE [] END |
  MERGE (a)-[r:EXHIBITED_WITH]->(b)
  SET r.sharedExhibitionCount = SIZE(shared_exhibitions)
)




CALL apoc.periodic.iterate(
  '
  MATCH (a:Artist)-[:EXHIBITED]->(e:Exhibition)
  WITH DISTINCT a
  RETURN a
  ',
  '
  // Repeat collection for all artists, then perform pair comparison
  MATCH (b:Artist)
  WHERE a <> b // Ensure unique pairs and avoid self-comparison
  WITH a, b
  
  // Process exhibitions for each pair of artists
  UNWIND [(a)-->(e:Exhibition)<--(b) | e.id] AS a_exhibition_ids
  UNWIND [(b)-->(e:Exhibition)<--(a) | e.id] AS b_exhibition_ids
  
  // Calculate the intersection of their exhibition lists
  WITH a, b, COLLECT(DISTINCT a_exhibition_ids) AS a_exhibition_ids, COLLECT(DISTINCT b_exhibition_ids) AS b_exhibition_ids
  WHERE a_exhibition_ids <> [] AND b_exhibition_ids <> [] // Ensure non-empty lists
  WITH a, b, a_exhibition_ids, b_exhibition_ids
  
  // Create or update EXHIBITED_WITH relationships with shared exhibition count for all pairs
  FOREACH (ignored IN CASE WHEN SIZE([x IN a_exhibition_ids WHERE x IN b_exhibition_ids]) > 0 THEN [1] ELSE [] END |
    MATCH(a)-[r:EXHIBITED_WITH]->(b)
    SET r.sharedExhibitionCount = SIZE([x IN a_exhibition_ids WHERE x IN b_exhibition_ids])
  )
  ',
  {
    batchSize: 1000,
    parallel: true,
    iterateList: true
  }
)


New idea:
First save amount of exhibited artworks for every artist with every exhibition 
MATCH (a:Artist)-[r:EXHIBITED]->(e:Exhibition)
WITH a, e, count(r) AS times
MERGE (a)-[r_modified:EXHIBITED_MODIFIED]->(e)
SET r_modified.AmountExhibitedArtworks = times


MATCH (a1:Artist)-[r1:EXHIBITED_MODIFIED]->(e:Exhibition)<-[r2:EXHIBITED_MODIFIED]-(a2:Artist)
WHERE id(a1) < id(a2)
WITH a1, a2, e, r1.AmountExhibitedArtworks AS a1Amount, r2.AmountExhibitedArtworks AS a2Amount
WITH a1, a2, a1Amount, a2Amount, SUM(a1Amount + a2Amount) AS TotalArtworks,  COLLECT(DISTINCT e) AS sharedExhibitions
RETURN a1.id AS Artist1ID, a2.id AS Artist2ID, TotalArtworks, size(sharedExhibitions), a1Amount, a2Amount
ORDER BY TotalArtworks DESC
LIMIT 100
WHAT TO DO, WHAT TO SAVE???



Counts how often exhibited together but same exhibition multiplied also by how many artworks they exhibited there
MATCH (a1:Artist)
WITH a1 ORDER BY a1.name LIMIT 100
MATCH (a1)-[:EXHIBITED]->(e:Exhibition)<-[:EXHIBITED]-(a2:Artist)
WHERE id(a1) < id(a2)
WITH a1, a2, collect(e) AS sharedExhibitions
RETURN a1.lastname AS Artist1, a2.lastname AS Artist2, size(sharedExhibitions) AS TimesExhibitedTogether
ORDER BY TimesExhibitedTogether DESC
LIMIT 100

Counts how often exhibited at same exhibition ()not including how many artworks
// Match pairs of artists and their shared exhibitions
MATCH (a1:Artist)-[:EXHIBITED]->(e:Exhibition)<-[:EXHIBITED]-(a2:Artist)
WHERE id(a1) < id(a2)
WITH a1, a2, COLLECT(DISTINCT e) AS sharedExhibitions
MERGE (a1)-[r:EXHIBITED_WITH]-(a2)
SET r.sharedExhibitions = SIZE(sharedExhibitions)

Zum Einfügen der Properties in Artist:
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Techniquesnd amountTechniques:
MATCH (a:Artist)-[:CREATED]->(b:CatalogueEntry)
WHERE b.technique <> '\\N'
WITH a, COLLECT(b.technique) AS techniques
MERGE (a)
SET a.amountTechniques = SIZE(techniques)
SET a.techniques = techniques

Artforms und amountArtforms:
MATCH (a:Artist)-[:CREATED]->(b:CatalogueEntry)
WHERE b.artForm <> '\\N'
WITH a, COLLECT(b.artForm) AS artForms
SET a.amountArtForms = SIZE(artForms)
SET a.artForms= artForms

Added distinct artforms:
MATCH (a:Artist)-[:CREATED]->(b:CatalogueEntry)
WHERE b.artForm <> '\\N'
WITH a, COLLECT(DISTINCT b.artForm) AS artForms
SET a.distinctArtForms = artForms



FOR COMMUNITY DETECTION
^^^^^^^^^^^^^^^^^^^^^^
// First, collect the necessary nodes and relationships into lists
MATCH (a:Artist)
WHERE EXISTS(a.artForms) AND a.country <> '\\N'
WITH a
WITH collect(a) AS selectedArtists
UNWIND selectedArtists AS a
MATCH (a)-[r:EXHIBITED_WITH]-(b)
WHERE b IN selectedArtists
WITH collect(a) AS nodes, collect(r) AS rels

// Now, use a Cypher projection to create the in-memory graph
CALL gds.graph.project.cypher(
    'myGraph2',
    'MATCH (n) WHERE n IN $nodes RETURN id(n) AS id',
    'MATCH (n)-[r:EXHIBITED_WITH]->(m) WHERE n IN $nodes AND m IN $nodes RETURN id(n) AS source, id(m) AS target',
    {parameters: {nodes: nodes}}
)YIELD graphName, nodeCount, relationshipCount
RETURN graphName, nodeCount, relationshipCount

SMaller graph:
// First, collect the necessary nodes and relationships into lists
MATCH (a:Artist)
WHERE EXISTS(a.artForms) AND a.country <> '\\N'
WITH a
LIMIT 1000
WITH collect(a) AS selectedArtists
UNWIND selectedArtists AS a
MATCH (a)-[r:EXHIBITED_WITH]-(b)
WHERE b IN selectedArtists
WITH collect(a) AS nodes, collect(r) AS rels

// Now, use a Cypher projection to create the in-memory graph
CALL gds.graph.project.cypher(
    'graph',
    'MATCH (n) WHERE n IN $nodes RETURN id(n) AS id',
    'MATCH (n)-[r:EXHIBITED_WITH]->(m) WHERE n IN $nodes AND m IN $nodes RETURN id(n) AS source, id(m) AS target',
    {parameters: {nodes: nodes}}
)YIELD graphName, nodeCount, relationshipCount
RETURN graphName, nodeCount, relationshipCount