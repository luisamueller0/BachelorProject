[
  {
    "name": "apoc.algo.aStar",
    "signature": "apoc.algo.aStar(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, latPropertyName :: STRING?, lonPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)",
    "description": "apoc.algo.aStar(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance','lat','lon') YIELD path, weight - run A* with relationship property name as cost function",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.aStarConfig",
    "signature": "apoc.algo.aStarConfig(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, config :: MAP?) :: (path :: PATH?, weight :: FLOAT?)",
    "description": "apoc.algo.aStarConfig(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', {weight:'dist',default:10,x:'lon',y:'lat', pointPropName:'point'}) YIELD path, weight - run A* with relationship property name as cost function",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.aStarWithPoint",
    "signature": "apoc.algo.aStarWithPoint(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, pointPropertyName :: STRING?) :: (path :: PATH?, weight :: FLOAT?)",
    "description": "apoc.algo.aStarWithPoint(startNode, endNode, 'relTypesAndDirs', 'distance','pointProp') - equivalent to apoc.algo.aStar but accept a Point type as a pointProperty instead of Number types as latitude and longitude properties",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.allSimplePaths",
    "signature": "apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)",
    "description": "apoc.algo.allSimplePaths(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 5) YIELD path, weight - run allSimplePaths with relationships given and maxNodes",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.cover",
    "signature": "apoc.algo.cover(nodes :: ANY?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.algo.cover(nodes) yield rel - returns all relationships between this set of nodes",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.dijkstra",
    "signature": "apoc.algo.dijkstra(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight = NaN :: FLOAT?, numberOfWantedPaths = 1 :: INTEGER?) :: (path :: PATH?, weight :: FLOAT?)",
    "description": "apoc.algo.dijkstra(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', defaultValue, numberOfWantedResults) YIELD path, weight - run dijkstra with relationship property name as cost function",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.algo.dijkstraWithDefaultWeight",
    "signature": "apoc.algo.dijkstraWithDefaultWeight(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, weightPropertyName :: STRING?, defaultWeight :: FLOAT?) :: (path :: PATH?, weight :: FLOAT?)",
    "description": "apoc.algo.dijkstraWithDefaultWeight(startNode, endNode, 'KNOWS|<WORKS_WITH|IS_MANAGER_OF>', 'distance', 10) YIELD path, weight - run dijkstra with relationship property name as cost function and a default weight if the property does not exist",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.add",
    "signature": "apoc.atomic.add(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.add(node/relatonship,propertyName,number) Sums the property's value with the 'number' value ",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.concat",
    "signature": "apoc.atomic.concat(container :: ANY?, propertyName :: STRING?, string :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.concat(node/relatonship,propertyName,string) Concats the property's value with the 'string' value",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.insert",
    "signature": "apoc.atomic.insert(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, value :: ANY?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.insert(node/relatonship,propertyName,position,value) insert a value into the property's array value at 'position'",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.remove",
    "signature": "apoc.atomic.remove(container :: ANY?, propertyName :: STRING?, position :: INTEGER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.remove(node/relatonship,propertyName,position) remove the element at position 'position'",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.subtract",
    "signature": "apoc.atomic.subtract(container :: ANY?, propertyName :: STRING?, number :: NUMBER?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.subtract(node/relatonship,propertyName,number) Subtracts the 'number' value to the property's value",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.atomic.update",
    "signature": "apoc.atomic.update(container :: ANY?, propertyName :: STRING?, operation :: STRING?, times = 5 :: INTEGER?) :: (container :: ANY?, property :: STRING?, oldValue :: ANY?, newValue :: ANY?)",
    "description": "apoc.atomic.update(node/relatonship,propertyName,updateOperation) update a property's value with a cypher operation (ex. \"n.prop1+n.prop2\")",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.bolt.execute",
    "signature": "apoc.bolt.execute(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "apoc.bolt.execute(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for reads and writes",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.bolt.load",
    "signature": "apoc.bolt.load(url :: STRING?, kernelTransaction :: STRING?, params = {} :: MAP?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "apoc.bolt.load(url-or-key, kernelTransaction, params, config) - access to other databases via bolt for read",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.bolt.load.fromLocal",
    "signature": "apoc.bolt.load.fromLocal(url :: STRING?, localStatement :: STRING?, remoteStatement :: STRING?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.case",
    "signature": "apoc.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / read-only query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cluster.graph",
    "signature": "apoc.cluster.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.coll.elements",
    "signature": "apoc.coll.elements(values :: LIST? OF ANY?, limit = -1 :: INTEGER?, offset = 0 :: INTEGER?) :: (_1 :: ANY?, _2 :: ANY?, _3 :: ANY?, _4 :: ANY?, _5 :: ANY?, _6 :: ANY?, _7 :: ANY?, _8 :: ANY?, _9 :: ANY?, _10 :: ANY?, _1s :: STRING?, _2s :: STRING?, _3s :: STRING?, _4s :: STRING?, _5s :: STRING?, _6s :: STRING?, _7s :: STRING?, _8s :: STRING?, _9s :: STRING?, _10s :: STRING?, _1i :: INTEGER?, _2i :: INTEGER?, _3i :: INTEGER?, _4i :: INTEGER?, _5i :: INTEGER?, _6i :: INTEGER?, _7i :: INTEGER?, _8i :: INTEGER?, _9i :: INTEGER?, _10i :: INTEGER?, _1f :: FLOAT?, _2f :: FLOAT?, _3f :: FLOAT?, _4f :: FLOAT?, _5f :: FLOAT?, _6f :: FLOAT?, _7f :: FLOAT?, _8f :: FLOAT?, _9f :: FLOAT?, _10f :: FLOAT?, _1b :: BOOLEAN?, _2b :: BOOLEAN?, _3b :: BOOLEAN?, _4b :: BOOLEAN?, _5b :: BOOLEAN?, _6b :: BOOLEAN?, _7b :: BOOLEAN?, _8b :: BOOLEAN?, _9b :: BOOLEAN?, _10b :: BOOLEAN?, _1l :: LIST? OF ANY?, _2l :: LIST? OF ANY?, _3l :: LIST? OF ANY?, _4l :: LIST? OF ANY?, _5l :: LIST? OF ANY?, _6l :: LIST? OF ANY?, _7l :: LIST? OF ANY?, _8l :: LIST? OF ANY?, _9l :: LIST? OF ANY?, _10l :: LIST? OF ANY?, _1m :: MAP?, _2m :: MAP?, _3m :: MAP?, _4m :: MAP?, _5m :: MAP?, _6m :: MAP?, _7m :: MAP?, _8m :: MAP?, _9m :: MAP?, _10m :: MAP?, _1n :: NODE?, _2n :: NODE?, _3n :: NODE?, _4n :: NODE?, _5n :: NODE?, _6n :: NODE?, _7n :: NODE?, _8n :: NODE?, _9n :: NODE?, _10n :: NODE?, _1r :: RELATIONSHIP?, _2r :: RELATIONSHIP?, _3r :: RELATIONSHIP?, _4r :: RELATIONSHIP?, _5r :: RELATIONSHIP?, _6r :: RELATIONSHIP?, _7r :: RELATIONSHIP?, _8r :: RELATIONSHIP?, _9r :: RELATIONSHIP?, _10r :: RELATIONSHIP?, _1p :: PATH?, _2p :: PATH?, _3p :: PATH?, _4p :: PATH?, _5p :: PATH?, _6p :: PATH?, _7p :: PATH?, _8p :: PATH?, _9p :: PATH?, _10p :: PATH?, elements :: INTEGER?)",
    "description": "apoc.coll.elements(list,limit,offset) yield _1,_2,..,_10,_1s,_2i,_3f,_4m,_5l,_6n,_7r,_8p - deconstruct subset of mixed list into identifiers of the correct type",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.coll.pairWithOffset",
    "signature": "apoc.coll.pairWithOffset(values :: LIST? OF ANY?, offset :: INTEGER?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.coll.pairWithOffset(values, offset) - returns a list of pairs defined by the offset",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.coll.partition",
    "signature": "apoc.coll.partition(values :: LIST? OF ANY?, batchSize :: INTEGER?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.coll.partition(list,batchSize)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.coll.split",
    "signature": "apoc.coll.split(values :: LIST? OF ANY?, value :: ANY?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.coll.split(list,value) | splits collection on given values rows of lists, value itself will not be part of resulting lists",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.coll.zipToRows",
    "signature": "apoc.coll.zipToRows(list1 :: LIST? OF ANY?, list2 :: LIST? OF ANY?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.coll.zipToRows(list1,list2) - creates pairs like zip but emits one row per pair",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.config.list",
    "signature": "apoc.config.list() :: (key :: STRING?, value :: ANY?)",
    "description": "apoc.config.list | Lists the Neo4j configuration as key,value table",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.config.map",
    "signature": "apoc.config.map() :: (value :: MAP?)",
    "description": "apoc.config.map | Lists the Neo4j configuration as map",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.convert.setJsonProperty",
    "signature": "apoc.convert.setJsonProperty(node :: NODE?, key :: STRING?, value :: ANY?) :: VOID",
    "description": "apoc.convert.setJsonProperty(node,key,complexValue) - sets value serialized to JSON as property with the given name on the node",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.convert.toTree",
    "signature": "apoc.convert.toTree(paths :: LIST? OF PATH?, lowerCaseRels = true :: BOOLEAN?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.convert.toTree([paths],[lowerCaseRels=true], [config]) creates a stream of nested documents representing the at least one root of these paths",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.append",
    "signature": "apoc.couchbase.append(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?, config = {} :: MAP?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.append(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - append a couchbase json document to an existing one.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.exists",
    "signature": "apoc.couchbase.exists(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.couchbase.exists(hostOrKey, bucket, documentId) yield value - check whether a couchbase json document with the given ID does exist.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.get",
    "signature": "apoc.couchbase.get(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.get(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - retrieves a couchbase json document by its unique ID.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.insert",
    "signature": "apoc.couchbase.insert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.insert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert a couchbase json document with its unique ID.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.namedParamsQuery",
    "signature": "apoc.couchbase.namedParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, paramNames :: LIST? OF STRING?, paramValues :: LIST? OF ANY?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",
    "description": "apoc.couchbase.namedParamsQuery(hostkOrKey, bucket, statement, paramNames, paramValues) yield queryResult - executes a N1QL statement with named parameters.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.posParamsQuery",
    "signature": "apoc.couchbase.posParamsQuery(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",
    "description": "apoc.couchbase.posParamsQuery(hostOrKey, bucket, statement, params) yield queryResult - executes a N1QL statement with positional parameters.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.prepend",
    "signature": "apoc.couchbase.prepend(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, content :: BYTEARRAY?, config = {} :: MAP?) :: (content :: BYTEARRAY?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.prepend(hostOrKey, bucket, documentId, content) yield id, expiry, cas, mutationToken, content - prepend a couchbase json document to an existing one.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.query",
    "signature": "apoc.couchbase.query(hostOrKey :: STRING?, bucket :: STRING?, statement :: STRING?, config = {} :: MAP?) :: (queryResult :: LIST? OF MAP?)",
    "description": "apoc.couchbase.query(hostOrKey, bucket, statement) yield queryResult - executes a plain un-parameterized N1QL statement.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.remove",
    "signature": "apoc.couchbase.remove(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.remove(hostOrKey, bucket, documentId) yield id, expiry, cas, mutationToken, content - remove the couchbase json document identified by its unique ID.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.replace",
    "signature": "apoc.couchbase.replace(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.replace(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - replace the content of the couchbase json document identified by its unique ID.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.couchbase.upsert",
    "signature": "apoc.couchbase.upsert(hostOrKey :: STRING?, bucket :: STRING?, documentId :: STRING?, json :: STRING?, config = {} :: MAP?) :: (content :: MAP?, id :: STRING?, expiry :: INTEGER?, cas :: INTEGER?, mutationToken :: MAP?)",
    "description": "apoc.couchbase.upsert(hostOrKey, bucket, documentId, jsonDocument) yield id, expiry, cas, mutationToken, content - insert or overwrite a couchbase json document with its unique ID.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.addLabels",
    "signature": "apoc.create.addLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
    "description": "apoc.create.addLabels( [node,id,ids,nodes], ['Label',...]) - adds the given labels to the node or nodes",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.clonePathToVirtual",
    "signature": "apoc.create.clonePathToVirtual(path :: PATH?) :: (path :: PATH?)",
    "description": "apoc.create.clonePathToVirtual",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.clonePathsToVirtual",
    "signature": "apoc.create.clonePathsToVirtual(paths :: LIST? OF PATH?) :: (path :: PATH?)",
    "description": "apoc.create.clonePathsToVirtual",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.node",
    "signature": "apoc.create.node(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",
    "description": "apoc.create.node(['Label'], {key:value,...}) - create node with dynamic labels",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.nodes",
    "signature": "apoc.create.nodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",
    "description": "apoc.create.nodes(['Label'], [{key:value,...}]) create multiple nodes with dynamic labels",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.relationship",
    "signature": "apoc.create.relationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.create.relationship(person1,'KNOWS',{key:value,...}, person2) create relationship with dynamic rel-type",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.removeLabels",
    "signature": "apoc.create.removeLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
    "description": "apoc.create.removeLabels( [node,id,ids,nodes], ['Label',...]) - removes the given labels from the node or nodes",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.removeProperties",
    "signature": "apoc.create.removeProperties(nodes :: ANY?, keys :: LIST? OF STRING?) :: (node :: NODE?)",
    "description": "apoc.create.removeProperties( [node,id,ids,nodes], [keys]) - removes the given properties from the nodes(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.removeRelProperties",
    "signature": "apoc.create.removeRelProperties(rels :: ANY?, keys :: LIST? OF STRING?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.create.removeRelProperties( [rel,id,ids,rels], [keys]) - removes the given properties from the relationship(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.setLabels",
    "signature": "apoc.create.setLabels(nodes :: ANY?, label :: LIST? OF STRING?) :: (node :: NODE?)",
    "description": "apoc.create.setLabels( [node,id,ids,nodes], ['Label',...]) - sets the given labels, non matching labels are removed on the node or nodes",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.setProperties",
    "signature": "apoc.create.setProperties(nodes :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (node :: NODE?)",
    "description": "apoc.create.setProperties( [node,id,ids,nodes], [keys], [values]) - sets the given properties on the nodes(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.setProperty",
    "signature": "apoc.create.setProperty(nodes :: ANY?, key :: STRING?, value :: ANY?) :: (node :: NODE?)",
    "description": "apoc.create.setProperty( [node,id,ids,nodes], key, value) - sets the given property on the node(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.setRelProperties",
    "signature": "apoc.create.setRelProperties(rels :: ANY?, keys :: LIST? OF STRING?, values :: LIST? OF ANY?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.create.setRelProperties( [rel,id,ids,rels], [keys], [values]) - sets the given properties on the relationship(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.setRelProperty",
    "signature": "apoc.create.setRelProperty(relationships :: ANY?, key :: STRING?, value :: ANY?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.create.setRelProperty( [rel,id,ids,rels], key, value) - sets the given property on the relationship(s)",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.uuids",
    "signature": "apoc.create.uuids(count :: INTEGER?) :: (row :: INTEGER?, uuid :: STRING?)",
    "description": "apoc.create.uuids(count) yield uuid - creates 'count' UUIDs ",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.vNode",
    "signature": "apoc.create.vNode(label :: LIST? OF STRING?, props :: MAP?) :: (node :: NODE?)",
    "description": "apoc.create.vNode(['Label'], {key:value,...}) returns a virtual node",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.vNodes",
    "signature": "apoc.create.vNodes(label :: LIST? OF STRING?, props :: LIST? OF MAP?) :: (node :: NODE?)",
    "description": "apoc.create.vNodes(['Label'], [{key:value,...}]) returns virtual nodes",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.vPattern",
    "signature": "apoc.create.vPattern(from :: MAP?, relType :: STRING?, props :: MAP?, to :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
    "description": "apoc.create.vPattern({_labels:['LabelA'],key:value},'KNOWS',{key:value,...}, {_labels:['LabelB'],key:value}) returns a virtual pattern",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.vPatternFull",
    "signature": "apoc.create.vPatternFull(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
    "description": "apoc.create.vPatternFull(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual pattern",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.vRelationship",
    "signature": "apoc.create.vRelationship(from :: NODE?, relType :: STRING?, props :: MAP?, to :: NODE?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.create.vRelationship(nodeFrom,'KNOWS',{key:value,...}, nodeTo) returns a virtual relationship",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.create.virtualPath",
    "signature": "apoc.create.virtualPath(labelsN :: LIST? OF STRING?, n :: MAP?, relType :: STRING?, props :: MAP?, labelsM :: LIST? OF STRING?, m :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
    "description": "apoc.create.virtualPath(['LabelA'],{key:value},'KNOWS',{key:value,...},['LabelB'],{key:value}) returns a virtual path of nodes joined by a relationship and the associated properties",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.asFunction",
    "signature": "apoc.custom.asFunction(name :: STRING?, statement :: STRING?, outputs =  :: STRING?, inputs = null :: LIST? OF LIST? OF STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID",
    "description": "apoc.custom.asFunction(name, statement, outputs, inputs, forceSingle, description) - register a custom cypher function",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.asProcedure",
    "signature": "apoc.custom.asProcedure(name :: STRING?, statement :: STRING?, mode = read :: STRING?, outputs = null :: LIST? OF LIST? OF STRING?, inputs = null :: LIST? OF LIST? OF STRING?, description =  :: STRING?) :: VOID",
    "description": "apoc.custom.asProcedure(name, statement, mode, outputs, inputs, description) - register a custom cypher procedure",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.declareFunction",
    "signature": "apoc.custom.declareFunction(signature :: STRING?, statement :: STRING?, forceSingle = false :: BOOLEAN?, description =  :: STRING?) :: VOID",
    "description": "apoc.custom.declareFunction(signature, statement, forceSingle, description) - register a custom cypher function",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.declareProcedure",
    "signature": "apoc.custom.declareProcedure(signature :: STRING?, statement :: STRING?, mode = read :: STRING?, description =  :: STRING?) :: VOID",
    "description": "apoc.custom.declareProcedure(signature, statement, mode, description) - register a custom cypher procedure",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.list",
    "signature": "apoc.custom.list() :: (type :: STRING?, name :: STRING?, description :: STRING?, mode :: STRING?, statement :: STRING?, inputs :: LIST? OF LIST? OF STRING?, outputs :: ANY?, forceSingle :: BOOLEAN?)",
    "description": "apoc.custom.list() - provide a list of custom procedures/function registered",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.removeFunction",
    "signature": "apoc.custom.removeFunction(name :: STRING?) :: VOID",
    "description": "apoc.custom.removeFunction(name, type) - remove the targeted custom function",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.custom.removeProcedure",
    "signature": "apoc.custom.removeProcedure(name :: STRING?) :: VOID",
    "description": "apoc.custom.removeProcedure(name) - remove the targeted custom procedure",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.doIt",
    "signature": "apoc.cypher.doIt(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
    "description": "apoc.cypher.doIt(fragment, params) yield value - executes writing fragment with the given parameters",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.mapParallel",
    "signature": "apoc.cypher.mapParallel(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?) :: (value :: MAP?)",
    "description": "apoc.cypher.mapParallel(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.mapParallel2",
    "signature": "apoc.cypher.mapParallel2(fragment :: STRING?, params :: MAP?, list :: LIST? OF ANY?, partitions :: INTEGER?, timeout = 10 :: INTEGER?) :: (value :: MAP?)",
    "description": "apoc.cypher.mapParallel2(fragment, params, list-to-parallelize) yield value - executes fragment in parallel batches with the list segments being assigned to _",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.parallel",
    "signature": "apoc.cypher.parallel(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",
    "description": "apoc.cypher.parallel(fragment, `paramMap`, `keyList`) yield value - executes fragments in parallel through a list defined in `paramMap` with a key `keyList`",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.parallel2",
    "signature": "apoc.cypher.parallel2(fragment :: STRING?, params :: MAP?, parallelizeOn :: STRING?) :: (value :: MAP?)",
    "description": "apoc.cypher.parallel2(fragment, `paramMap`, `keyList`) yield value - executes fragments in parallel batches through a list defined in `paramMap` with a key `keyList`",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.run",
    "signature": "apoc.cypher.run(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
    "description": "apoc.cypher.run(fragment, params) yield value - executes reading fragment with the given parameters - currently no schema operations",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runFile",
    "signature": "apoc.cypher.runFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runFile(file or url,[{statistics:true,timeout:10,parameters:{}}]) - runs each statement in the file, all semicolon separated - currently no schema operations",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runFiles",
    "signature": "apoc.cypher.runFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runFiles([files or urls],[{statistics:true,timeout:10,parameters:{}}])) - runs each statement in the files, all semicolon separated",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runMany",
    "signature": "apoc.cypher.runMany(cypher :: STRING?, params :: MAP?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runMany('cypher;\nstatements;', $params, [{statistics:true,timeout:10}]) - runs each semicolon separated statement and returns summary - currently no schema operations",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runManyReadOnly",
    "signature": "apoc.cypher.runManyReadOnly(cypher :: STRING?, params :: MAP?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runManyReadOnly('cypher;\nstatements;', $params, [{statistics:true,timeout:10}]) - runs each semicolon separated, read-only statement and returns summary - currently no schema operations",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runSchema",
    "signature": "apoc.cypher.runSchema(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
    "description": "apoc.cypher.runSchema(statement, params) yield value - executes query schema statement with the given parameters",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runSchemaFile",
    "signature": "apoc.cypher.runSchemaFile(file :: STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runSchemaFile(file or url,[{statistics:true,timeout:10}]) - allows only schema operations, runs each schema statement in the file, all semicolon separated",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runSchemaFiles",
    "signature": "apoc.cypher.runSchemaFiles(file :: LIST? OF STRING?, config = {} :: MAP?) :: (row :: INTEGER?, result :: MAP?)",
    "description": "apoc.cypher.runSchemaFiles([files or urls],{statistics:true,timeout:10}) - allows only schema operations, runs each schema statement in the files, all semicolon separated",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runTimeboxed",
    "signature": "apoc.cypher.runTimeboxed(cypher :: STRING?, params :: MAP?, timeout :: INTEGER?) :: (value :: MAP?)",
    "description": "apoc.cypher.runTimeboxed('cypherStatement',{params}, timeout) - abort kernelTransaction after timeout ms if not finished",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.cypher.runWrite",
    "signature": "apoc.cypher.runWrite(cypher :: STRING?, params :: MAP?) :: (value :: MAP?)",
    "description": "apoc.cypher.runWrite(statement, params) yield value - alias for apoc.cypher.doIt",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.date.expire",
    "signature": "apoc.date.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID",
    "description": "CALL apoc.date.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.date.expireIn",
    "signature": "apoc.date.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID",
    "description": "CALL apoc.date.expireIn(node,time,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.do.case",
    "signature": "apoc.do.case(conditionals :: LIST? OF ANY?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.do.case([condition, query, condition, query, ...], elseQuery:'', params:{}) yield value - given a list of conditional / writing query pairs, executes the query associated with the first conditional evaluating to true (or the else query if none are true) with the given parameters",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.do.when",
    "signature": "apoc.do.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.do.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes writing ifQuery or elseQuery with the given parameters",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.dv.catalog.add",
    "signature": "apoc.dv.catalog.add(name :: STRING?, config = {} :: MAP?) :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",
    "description": "Add a virtualized resource configuration",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.dv.catalog.list",
    "signature": "apoc.dv.catalog.list() :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",
    "description": "List all virtualized resource configuration",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.dv.catalog.remove",
    "signature": "apoc.dv.catalog.remove(name :: STRING?) :: (name :: STRING?, type :: STRING?, url :: STRING?, desc :: STRING?, labels :: LIST? OF STRING?, query :: STRING?, params :: LIST? OF STRING?)",
    "description": "Remove a virtualized resource config by name",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.dv.query",
    "signature": "apoc.dv.query(name :: STRING?, params = {} :: ANY?, config = {} :: MAP?) :: (node :: NODE?)",
    "description": "Query a virtualized resource by name and return virtual nodes",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.dv.queryAndLink",
    "signature": "apoc.dv.queryAndLink(node :: NODE?, relName :: STRING?, name :: STRING?, params = {} :: ANY?, config = {} :: MAP?) :: (path :: PATH?)",
    "description": "Query a virtualized resource by name and return virtual nodes linked using virtual rels to the node passed as first param",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.get",
    "signature": "apoc.es.get(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
    "description": "apoc.es.get(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a GET operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.getRaw",
    "signature": "apoc.es.getRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",
    "description": "apoc.es.getRaw(host-or-port,path,payload-or-null) yield value - perform a raw GET operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.post",
    "signature": "apoc.es.post(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.es.post(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a POST operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.postRaw",
    "signature": "apoc.es.postRaw(host :: STRING?, path :: STRING?, payload :: ANY?) :: (value :: MAP?)",
    "description": "apoc.es.postRaw(host-or-port,path,payload-or-null) yield value - perform a raw POST operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.put",
    "signature": "apoc.es.put(host :: STRING?, index :: STRING?, type :: STRING?, id :: STRING?, query :: ANY?, payload = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.es.put(host-or-port,index-or-null,type-or-null,id-or-null,query-or-null,payload-or-null) yield value - perform a PUT operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.query",
    "signature": "apoc.es.query(host :: STRING?, index :: STRING?, type :: STRING?, query :: ANY?, payload :: ANY?) :: (value :: MAP?)",
    "description": "apoc.es.query(host-or-port,index-or-null,type-or-null,query-or-null,payload-or-null) yield value - perform a SEARCH operation on elastic search",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.es.stats",
    "signature": "apoc.es.stats(host :: STRING?) :: (value :: MAP?)",
    "description": "apoc.es.stats(host-url-Key) - elastic search statistics",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.example.movies",
    "signature": "apoc.example.movies() :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.example.movies() | Creates the sample movies graph",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.all",
    "signature": "apoc.export.arrow.all(fileName :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.arrow.all(fileName, config) - exports whole database as arrow file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.graph",
    "signature": "apoc.export.arrow.graph(fileName :: STRING?, graph :: ANY?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.arrow.graph(fileName, graph, config) - exports given nodes and relationships as arrow file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.query",
    "signature": "apoc.export.arrow.query(fileName :: STRING?, query :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.arrow.query(fileName, query, config) - exports results from the cypher statement as arrow file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.stream.all",
    "signature": "apoc.export.arrow.stream.all(config = {} :: MAP?) :: (value :: BYTEARRAY?)",
    "description": "apoc.export.arrow.stream.all(config) - exports whole database as arrow byte[] result",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.stream.graph",
    "signature": "apoc.export.arrow.stream.graph(graph :: ANY?, config = {} :: MAP?) :: (value :: BYTEARRAY?)",
    "description": "apoc.export.arrow.stream.graph(graph, config) - exports given nodes and relationships as arrow byte[] result",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.arrow.stream.query",
    "signature": "apoc.export.arrow.stream.query(query :: STRING?, config = {} :: MAP?) :: (value :: BYTEARRAY?)",
    "description": "apoc.export.arrow.stream.query(query, config) - exports results from the cypher statement as arrow byte[] result",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.csv.all",
    "signature": "apoc.export.csv.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.csv.all(file,config) - exports whole database as csv to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.csv.data",
    "signature": "apoc.export.csv.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.csv.data(nodes,rels,file,config) - exports given nodes and relationships as csv to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.csv.graph",
    "signature": "apoc.export.csv.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.csv.graph(graph,file,config) - exports given graph object as csv to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.csv.query",
    "signature": "apoc.export.csv.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.csv.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as csv to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypher.all",
    "signature": "apoc.export.cypher.all(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypher.all(file,config) - exports whole database incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypher.data",
    "signature": "apoc.export.cypher.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypher.data(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypher.graph",
    "signature": "apoc.export.cypher.graph(graph :: MAP?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypher.graph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypher.query",
    "signature": "apoc.export.cypher.query(query :: STRING?, file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypher.query(query,file,config) - exports nodes and relationships from the cypher statement incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypher.schema",
    "signature": "apoc.export.cypher.schema(file =  :: STRING?, config = {} :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypher.schema(file,config) - exports all schema indexes and constraints to cypher",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypherAll",
    "signature": "apoc.export.cypherAll(file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypherAll(file,config) - exports whole database incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypherData",
    "signature": "apoc.export.cypherData(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypherData(nodes,rels,file,config) - exports given nodes and relationships incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypherGraph",
    "signature": "apoc.export.cypherGraph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypherGraph(graph,file,config) - exports given graph object incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.cypherQuery",
    "signature": "apoc.export.cypherQuery(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, batches :: INTEGER?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, cypherStatements :: ANY?, nodeStatements :: ANY?, relationshipStatements :: ANY?, schemaStatements :: ANY?, cleanupStatements :: ANY?)",
    "description": "apoc.export.cypherQuery(query,file,config) - exports nodes and relationships from the cypher kernelTransaction incl. indexes as cypher statements to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.graphml.all",
    "signature": "apoc.export.graphml.all(file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.graphml.all(file,config) - exports whole database as graphml to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.graphml.data",
    "signature": "apoc.export.graphml.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.graphml.data(nodes,rels,file,config) - exports given nodes and relationships as graphml to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.graphml.graph",
    "signature": "apoc.export.graphml.graph(graph :: MAP?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.graphml.graph(graph,file,config) - exports given graph object as graphml to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.graphml.query",
    "signature": "apoc.export.graphml.query(query :: STRING?, file :: STRING?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.graphml.query(query,file,config) - exports nodes and relationships from the cypher statement as graphml to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.json.all",
    "signature": "apoc.export.json.all(file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.json.all(file,config) - exports whole database as json to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.json.data",
    "signature": "apoc.export.json.data(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.json.data(nodes,rels,file,config) - exports given nodes and relationships as json to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.json.graph",
    "signature": "apoc.export.json.graph(graph :: MAP?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.json.graph(graph,file,config) - exports given graph object as json to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.export.json.query",
    "signature": "apoc.export.json.query(query :: STRING?, file :: STRING?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.export.json.query(query,file,{config,...,params:{params}}) - exports results from the cypher statement as json to the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.generate.ba",
    "signature": "apoc.generate.ba(noNodes :: INTEGER?, edgesPerNode :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
    "description": "apoc.generate.ba(noNodes, edgesPerNode, label, type) - generates a random graph according to the Barabasi-Albert model",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.generate.complete",
    "signature": "apoc.generate.complete(noNodes :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
    "description": "apoc.generate.complete(noNodes, label, type) - generates a random complete graph",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.generate.er",
    "signature": "apoc.generate.er(noNodes :: INTEGER?, noEdges :: INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
    "description": "apoc.generate.er(noNodes, noEdges, label, type) - generates a random graph according to the Erdos-Renyi model",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.generate.simple",
    "signature": "apoc.generate.simple(degrees :: LIST? OF INTEGER?, label :: STRING?, type :: STRING?) :: VOID",
    "description": "apoc.generate.simple(degrees, label, type) - generates a simple random graph according to the given degree distribution",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.generate.ws",
    "signature": "apoc.generate.ws(noNodes :: INTEGER?, degree :: INTEGER?, beta :: FLOAT?, label :: STRING?, type :: STRING?) :: VOID",
    "description": "apoc.generate.ws(noNodes, degree, beta, label, type) - generates a random graph according to the Watts-Strogatz model",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.gephi.add",
    "signature": "apoc.gephi.add(urlOrKey :: STRING?, workspace :: STRING?, data :: ANY?, weightproperty = null :: STRING?, exportproperties = [] :: LIST? OF STRING?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.gephi.add(url-or-key, workspace, data, weightproperty, ['exportproperty']) | streams passed in data to Gephi",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.get.nodes",
    "signature": "apoc.get.nodes(nodes :: ANY?) :: (node :: NODE?)",
    "description": "apoc.get.nodes(node|id|[ids]) - quickly returns all nodes with these id's",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.get.rels",
    "signature": "apoc.get.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these id's",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.from",
    "signature": "apoc.graph.from(data :: ANY?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.from(data,'name',{properties}) | creates a virtual graph object for later processing it tries its best to extract the graph information from the data you pass in",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromCypher",
    "signature": "apoc.graph.fromCypher(kernelTransaction :: STRING?, params :: MAP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromCypher('kernelTransaction',{params},'name',{properties}) - creates a virtual graph object for later processing",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromDB",
    "signature": "apoc.graph.fromDB(name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromDB('name',{properties}) - creates a virtual graph object for later processing",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromData",
    "signature": "apoc.graph.fromData(nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromData([nodes],[relationships],'name',{properties}) | creates a virtual graph object for later processing",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromDocument",
    "signature": "apoc.graph.fromDocument(json :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromDocument({json}, {config}) yield graph - transform JSON documents into graph structures",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromPath",
    "signature": "apoc.graph.fromPath(path :: PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromPath(path,'name',{properties}) - creates a virtual graph object for later processing",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.fromPaths",
    "signature": "apoc.graph.fromPaths(paths :: LIST? OF PATH?, name :: STRING?, properties :: MAP?) :: (graph :: MAP?)",
    "description": "apoc.graph.fromPaths([paths],'name',{properties}) - creates a virtual graph object for later processing",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.graph.validateDocument",
    "signature": "apoc.graph.validateDocument(json :: ANY?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "apoc.graph.validateDocument({json}, {config}) yield row - validates the json, return the result of the validation",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.help",
    "signature": "apoc.help(proc :: STRING?) :: (type :: STRING?, name :: STRING?, text :: STRING?, signature :: STRING?, roles :: LIST? OF STRING?, writes :: BOOLEAN?, core :: BOOLEAN?)",
    "description": "Provides descriptions of available procedures. To narrow the results, supply a search string. To also search in the description text, append + to the end of the search string.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.import.csv",
    "signature": "apoc.import.csv(nodes :: LIST? OF MAP?, relationships :: LIST? OF MAP?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.import.csv(nodes, relationships, config) - imports nodes and relationships from the provided CSV files with given labels and types",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.import.graphml",
    "signature": "apoc.import.graphml(urlOrBinaryFile :: ANY?, config :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.import.graphml(urlOrBinaryFile,config) - imports graphml file",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.import.json",
    "signature": "apoc.import.json(urlOrBinaryFile :: ANY?, config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "apoc.import.json(urlOrBinaryFile,config) - imports the json list to the provided file",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.import.xml",
    "signature": "apoc.import.xml(urlOrBinary :: ANY?, config = {} :: MAP?) :: (node :: NODE?)",
    "description": "apoc.import.xml(file,config) - imports graph from provided file",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.arrow",
    "signature": "apoc.load.arrow(source :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.arrow(fileName, config) - imports nodes and relationships from the provided file",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.arrow.stream",
    "signature": "apoc.load.arrow.stream(source :: BYTEARRAY?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.arrow.stream(source, config) - imports nodes and relationships from the provided byte[]",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.csv",
    "signature": "apoc.load.csv(urlOrBinary :: ANY?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)",
    "description": "apoc.load.csv('urlOrBinary',{config}) YIELD lineNo, list, map - load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.csvParams",
    "signature": "apoc.load.csvParams(urlOrBinary :: ANY?, httpHeaders :: MAP?, payload :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, list :: LIST? OF ANY?, strings :: LIST? OF STRING?, map :: MAP?, stringMap :: MAP?)",
    "description": "apoc.load.csvParams('urlOrBinary', {httpHeader: value}, payload, {config}) YIELD lineNo, list, map - load from CSV URL (e.g. web-api) while sending headers / payload to load CSV from URL as stream of values,
 config contains any of: {skip:1,limit:5,header:false,sep:'TAB',ignore:['tmp'],nullValues:['na'],arraySep:';',mapping:{years:{type:'int',arraySep:'-',array:false,name:'age',ignore:false}}",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.directory",
    "signature": "apoc.load.directory(pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (value :: STRING?)",
    "description": "apoc.load.directory('pattern', 'urlDir', {config}) YIELD value - Loads list of all files in folder specified by urlDir or in import folder if urlDir string is empty or not specified",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.directory.async.add",
    "signature": "apoc.load.directory.async.add(name :: STRING?, cypher :: STRING?, pattern = * :: STRING?, urlDir =  :: STRING?, config = {} :: MAP?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",
    "description": "apoc.load.directory.async.add(name, cypher, pattern, urlDir, {}) YIELD name, status, pattern, cypher, urlDir, config, error - Add or replace a folder listener with a specific name, pattern and url directory that execute the specified cypher query when an event is triggered and return listener list",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.directory.async.list",
    "signature": "apoc.load.directory.async.list() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",
    "description": "apoc.load.directory.async.list() YIELD name, status, pattern, cypher, urlDir, config, error - List of all folder listeners",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.directory.async.remove",
    "signature": "apoc.load.directory.async.remove(name :: STRING?) :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",
    "description": "apoc.load.directory.async.remove(name) YIELD name, status, pattern, cypher, urlDir, config, error - Remove a folder listener by name and return remaining listeners, if any",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.directory.async.removeAll",
    "signature": "apoc.load.directory.async.removeAll() :: (name :: STRING?, status :: STRING?, pattern :: STRING?, cypher :: STRING?, urlDir :: STRING?, config :: MAP?, error :: STRING?)",
    "description": "apoc.load.directory.async.removeAll() - Remove all folder listeners",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.driver",
    "signature": "apoc.load.driver(driverClass :: STRING?) :: VOID",
    "description": "apoc.load.driver('org.apache.derby.jdbc.EmbeddedDriver') register JDBC driver of source database",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.html",
    "signature": "apoc.load.html(url :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.html('url',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.htmlPlainText",
    "signature": "apoc.load.htmlPlainText(urlOrHtml :: STRING?, query = {} :: MAP?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.htmlPlainText('urlOrHtml',{name: jquery, name2: jquery}, config) YIELD value - Load Html page and return the result as a Map",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.jdbc",
    "signature": "apoc.load.jdbc(jdbc :: STRING?, tableOrSql :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "apoc.load.jdbc('key or url','table or statement', params, config) YIELD row - load from relational database, from a full table or a sql statement",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.jdbcParams",
    "signature": "apoc.load.jdbcParams(jdbc :: STRING?, sql :: STRING?, params :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "deprecated - please use: apoc.load.jdbc('key or url','',[params]) YIELD row - load from relational database, from a sql statement with parameters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.jdbcUpdate",
    "signature": "apoc.load.jdbcUpdate(jdbc :: STRING?, query :: STRING?, params = [] :: LIST? OF ANY?, config = {} :: MAP?) :: (row :: MAP?)",
    "description": "apoc.load.jdbcUpdate('key or url','statement',[params],config) YIELD row - update relational database, from a SQL statement with optional parameters",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.json",
    "signature": "apoc.load.json(urlOrKeyOrBinary :: ANY?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.json('urlOrKeyOrBinary',path, config) YIELD value - import JSON as stream of values if the JSON was an array or a single value if it was a map",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.jsonArray",
    "signature": "apoc.load.jsonArray(url :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.load.jsonArray('url') YIELD value - load array from JSON URL (e.g. web-api) to import JSON as stream of values",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.jsonParams",
    "signature": "apoc.load.jsonParams(urlOrKeyOrBinary :: ANY?, headers :: MAP?, payload :: STRING?, path =  :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.load.jsonParams('urlOrKeyOrBinary',{header:value},payload, config) YIELD value - load from JSON URL (e.g. web-api) while sending headers / payload to import JSON as stream of values if the JSON was an array or a single value if it was a map",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.ldap",
    "signature": "apoc.load.ldap(connection :: ANY?, search :: MAP?) :: (entry :: MAP?)",
    "description": "apoc.load.ldap(\"key\" or {connectionMap},{searchMap}) Load entries from an ldap source (yield entry)",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.load.xml",
    "signature": "apoc.load.xml(urlOrBinary :: ANY?, path = / :: STRING?, config = {} :: MAP?, simple = false :: BOOLEAN?) :: (value :: MAP?)",
    "description": "apoc.load.xml('http://example.com/test.xml', 'xPath',config, false) YIELD value as doc CREATE (p:Person) SET p.name = doc.name - load from XML URL (e.g. web-api) to import XML as single nested map with attributes and _type, _text and _childrenx fields.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.lock.all",
    "signature": "apoc.lock.all(nodes :: LIST? OF NODE?, rels :: LIST? OF RELATIONSHIP?) :: VOID",
    "description": "apoc.lock.all([nodes],[relationships]) acquires a write lock on the given nodes and relationships",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.lock.nodes",
    "signature": "apoc.lock.nodes(nodes :: LIST? OF NODE?) :: VOID",
    "description": "apoc.lock.nodes([nodes]) acquires a write lock on the given nodes",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.lock.read.nodes",
    "signature": "apoc.lock.read.nodes(nodes :: LIST? OF NODE?) :: VOID",
    "description": "apoc.lock.read.nodes([nodes]) acquires a read lock on the given nodes",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.lock.read.rels",
    "signature": "apoc.lock.read.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID",
    "description": "apoc.lock.read.rels([relationships]) acquires a read lock on the given relationship",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.lock.rels",
    "signature": "apoc.lock.rels(rels :: LIST? OF RELATIONSHIP?) :: VOID",
    "description": "apoc.lock.rels([relationships]) acquires a write lock on the given relationship",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.log.debug",
    "signature": "apoc.log.debug(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",
    "description": "apoc.log.debug(message, params) - logs debug message",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.log.error",
    "signature": "apoc.log.error(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",
    "description": "apoc.log.error(message, params) - logs error message",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.log.info",
    "signature": "apoc.log.info(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",
    "description": "apoc.log.info(message, params) - logs info message",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.log.stream",
    "signature": "apoc.log.stream(path :: STRING?, config = {} :: MAP?) :: (lineNo :: INTEGER?, line :: STRING?, path :: STRING?)",
    "description": "apoc.log.stream('neo4j.log', { last: n }) - retrieve log file contents, optionally return only the last n lines",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.log.warn",
    "signature": "apoc.log.warn(message :: STRING?, params = [] :: LIST? OF ANY?) :: VOID",
    "description": "apoc.log.warn(message, params) - logs warn message",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.math.regr",
    "signature": "apoc.math.regr(label :: STRING?, propertyY :: STRING?, propertyX :: STRING?) :: (r2 :: FLOAT?, avgX :: FLOAT?, avgY :: FLOAT?, slope :: FLOAT?)",
    "description": "apoc.math.regr(label, propertyY, propertyX) - It calculates the coefficient of determination (R-squared) for the values of propertyY and propertyX in the provided label",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.node",
    "signature": "apoc.merge.node(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)",
    "description": "\"apoc.merge.node(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes with dynamic labels, with support for setting properties ON CREATE or ON MATCH",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.node.eager",
    "signature": "apoc.merge.node.eager(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (node :: NODE?)",
    "description": "apoc.merge.node.eager(['Label'], identProps:{key:value, ...}, onCreateProps:{key:value,...}, onMatchProps:{key:value,...}}) - merge nodes eagerly, with dynamic labels, with support for setting properties ON CREATE or ON MATCH",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.nodeWithStats",
    "signature": "apoc.merge.nodeWithStats(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (stats :: MAP?, node :: NODE?)",
    "description": "apoc.merge.nodeWithStats - same as apoc.merge.node providing queryStatistics into result",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.nodeWithStats.eager",
    "signature": "apoc.merge.nodeWithStats.eager(label :: LIST? OF STRING?, identProps :: MAP?, props = {} :: MAP?, onMatchProps = {} :: MAP?) :: (stats :: MAP?, node :: NODE?)",
    "description": "apoc.merge.nodeWithStats.eager - same as apoc.merge.node.eager providing queryStatistics into result",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.relationship",
    "signature": "apoc.merge.relationship(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.relationship.eager",
    "signature": "apoc.merge.relationship.eager(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.merge.relationship(startNode, relType,  identProps:{key:value, ...}, onCreateProps:{key:value, ...}, endNode, onMatchProps:{key:value, ...}) - merge relationship with dynamic type, with support for setting properties ON CREATE or ON MATCH",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.relationshipWithStats",
    "signature": "apoc.merge.relationshipWithStats(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (stats :: MAP?, rel :: RELATIONSHIP?)",
    "description": "apoc.merge.relationshipWithStats - same as apoc.merge.relationship providing queryStatistics into result",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.merge.relationshipWithStats.eager",
    "signature": "apoc.merge.relationshipWithStats.eager(startNode :: NODE?, relationshipType :: STRING?, identProps :: MAP?, props :: MAP?, endNode :: NODE?, onMatchProps = {} :: MAP?) :: (stats :: MAP?, rel :: RELATIONSHIP?)",
    "description": "apoc.merge.relationshipWithStats.eager - same as apoc.merge.relationship.eager providing queryStatistics into result",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.data",
    "signature": "apoc.meta.data(config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)",
    "description": "apoc.meta.data({config})  - examines a subset of the graph to provide a tabular meta information",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.data.of",
    "signature": "apoc.meta.data.of(graph :: ANY?, config = {} :: MAP?) :: (label :: STRING?, property :: STRING?, count :: INTEGER?, unique :: BOOLEAN?, index :: BOOLEAN?, existence :: BOOLEAN?, type :: STRING?, array :: BOOLEAN?, sample :: LIST? OF ANY?, leftCount :: INTEGER?, rightCount :: INTEGER?, left :: INTEGER?, right :: INTEGER?, other :: LIST? OF STRING?, otherLabels :: LIST? OF STRING?, elementType :: STRING?)",
    "description": "apoc.meta.data.of({graph}, {config})  - examines a subset of the graph to provide a tabular meta information",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.graph",
    "signature": "apoc.meta.graph(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.meta.graph - examines the full graph to create the meta-graph",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.graph.of",
    "signature": "apoc.meta.graph.of(graph = {} :: ANY?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.meta.graph.of({graph}, {config})  - examines a subset of the graph to provide a graph meta information",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.graphSample",
    "signature": "apoc.meta.graphSample(config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.meta.graphSample() - examines the database statistics to build the meta graph, very fast, might report extra relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.nodeTypeProperties",
    "signature": "apoc.meta.nodeTypeProperties(config = {} :: MAP?) :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)",
    "description": "apoc.meta.nodeTypeProperties()",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.relTypeProperties",
    "signature": "apoc.meta.relTypeProperties(config = {} :: MAP?) :: (relType :: STRING?, sourceNodeLabels :: LIST? OF STRING?, targetNodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?, propertyObservations :: INTEGER?, totalObservations :: INTEGER?)",
    "description": "apoc.meta.relTypeProperties()",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.schema",
    "signature": "apoc.meta.schema(config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.meta.schema({config})  - examines a subset of the graph to provide a map-like meta information",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.stats",
    "signature": "apoc.meta.stats() :: (labelCount :: INTEGER?, relTypeCount :: INTEGER?, propertyKeyCount :: INTEGER?, nodeCount :: INTEGER?, relCount :: INTEGER?, labels :: MAP?, relTypes :: MAP?, relTypesCount :: MAP?, stats :: MAP?)",
    "description": "apoc.meta.stats yield labelCount, relTypeCount, propertyKeyCount, nodeCount, relCount, labels, relTypes, stats | returns the information stored in the transactional database statistics",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.meta.subGraph",
    "signature": "apoc.meta.subGraph(config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.meta.subGraph({labels:[labels],rels:[rel-types], excludes:[labels,rel-types]}) - examines a sample sub graph to create the meta-graph",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.metrics.get",
    "signature": "apoc.metrics.get(metricName :: STRING?, config = {} :: MAP?) :: (timestamp :: INTEGER?, metric :: STRING?, map :: MAP?)",
    "description": "apoc.metrics.get(metricName, {}) - retrieve a system metric by its metric name. Additional configuration options may be passed matching the options available for apoc.load.csv.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.metrics.list",
    "signature": "apoc.metrics.list() :: (name :: STRING?, lastUpdated :: INTEGER?)",
    "description": "apoc.metrics.list() - get a list of available metrics",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.metrics.storage",
    "signature": "apoc.metrics.storage(directorySetting :: STRING?) :: (setting :: STRING?, freeSpaceBytes :: INTEGER?, totalSpaceBytes :: INTEGER?, usableSpaceBytes :: INTEGER?, percentFree :: FLOAT?)",
    "description": "apoc.metrics.storage(directorySetting) - retrieve storage metrics about the devices Neo4j uses for data storage. directorySetting may be any valid neo4j directory setting name, such as 'dbms.directories.data'.  If null is provided as a directorySetting, you will get back all available directory settings.  For a list of available directory settings, see the Neo4j operations manual reference on configuration settings.   Directory settings are **not** paths, they are a neo4j.conf setting key name",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.model.jdbc",
    "signature": "apoc.model.jdbc(jdbc :: STRING?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.model.jdbc('key or url', {schema:'<schema>', write: <true/false>, filters: { tables:[], views: [], columns: []}) YIELD nodes, relationships - load schema from relational database",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.aggregate",
    "signature": "apoc.mongo.aggregate(uri :: STRING?, pipeline :: LIST? OF MAP?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.mongo.aggregate(uri, pipeline, $config) yield value - perform an aggregate operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.count",
    "signature": "apoc.mongo.count(uri :: STRING?, query :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongo.count(uri, query, $config) yield value - perform a count operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.delete",
    "signature": "apoc.mongo.delete(uri :: STRING?, query :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongo.delete(uri, query, $config) - delete the given documents from the mongodb collection and returns the number of affected documents",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.find",
    "signature": "apoc.mongo.find(uri :: STRING?, query = null :: ANY?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.mongo.find(uri, query, $config) yield value - perform a find operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.insert",
    "signature": "apoc.mongo.insert(uri :: STRING?, documents :: LIST? OF ANY?, config = {} :: MAP?) :: VOID",
    "description": "apoc.mongo.insert(uri, documents, $config) yield value - inserts the given documents into the mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongo.update",
    "signature": "apoc.mongo.update(uri :: STRING?, query :: ANY?, update :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongo.update(uri, query, update, $config) - updates the given documents from the mongodb collection and returns the number of affected documents",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.count",
    "signature": "apoc.mongodb.count(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongodb.count(host-or-key,db,collection,query) yield value - perform a find operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.delete",
    "signature": "apoc.mongodb.delete(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongodb.delete(host-or-key,db,collection,query) - delete the given documents from the mongodb collection and returns the number of affected documents",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.find",
    "signature": "apoc.mongodb.find(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, project :: MAP?, sort :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",
    "description": "apoc.mongodb.find(host-or-key,db,collection,query,projection,sort,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find,project,sort operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.first",
    "signature": "apoc.mongodb.first(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = true :: BOOLEAN?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",
    "description": "apoc.mongodb.first(host-or-key,db,collection,query,[compatibleValues=false|true],[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a first operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.get",
    "signature": "apoc.mongodb.get(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, compatibleValues = false :: BOOLEAN?, skip = 0 :: INTEGER?, limit = 0 :: INTEGER?, extractReferences = false :: BOOLEAN?, objectIdAsMap = true :: BOOLEAN?) :: (value :: MAP?)",
    "description": "apoc.mongodb.get(host-or-key,db,collection,query,[compatibleValues=false|true],skip-or-null,limit-or-null,[extractReferences=false|true],[objectIdAsMap=true|false]) yield value - perform a find operation on mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.get.byObjectId",
    "signature": "apoc.mongodb.get.byObjectId(host :: STRING?, db :: STRING?, collection :: STRING?, objectIdValue :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.mongodb.get.byObjectId(hostOrKey, db, collection, objectIdValue, config(default:{})) - get the document by Object id value",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.insert",
    "signature": "apoc.mongodb.insert(host :: STRING?, db :: STRING?, collection :: STRING?, documents :: LIST? OF MAP?) :: VOID",
    "description": "apoc.mongodb.insert(host-or-key,db,collection,documents) - inserts the given documents into the mongodb collection",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.mongodb.update",
    "signature": "apoc.mongodb.update(host :: STRING?, db :: STRING?, collection :: STRING?, query :: MAP?, update :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.mongodb.update(host-or-key,db,collection,query,update) - updates the given documents from the mongodb collection and returns the number of affected documents",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.monitor.ids",
    "signature": "apoc.monitor.ids() :: (nodeIds :: INTEGER?, relIds :: INTEGER?, propIds :: INTEGER?, relTypeIds :: INTEGER?)",
    "description": "apoc.monitor.ids() returns the object ids in use for this neo4j instance",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.monitor.kernel",
    "signature": "apoc.monitor.kernel() :: (readOnly :: BOOLEAN?, kernelVersion :: STRING?, storeId :: STRING?, kernelStartTime :: STRING?, databaseName :: STRING?, storeLogVersion :: INTEGER?, storeCreationDate :: STRING?)",
    "description": "apoc.monitor.kernel() returns informations about the neo4j kernel",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.monitor.store",
    "signature": "apoc.monitor.store() :: (logSize :: INTEGER?, stringStoreSize :: INTEGER?, arrayStoreSize :: INTEGER?, relStoreSize :: INTEGER?, propStoreSize :: INTEGER?, totalStoreSize :: INTEGER?, nodeStoreSize :: INTEGER?)",
    "description": "apoc.monitor.store() returns informations about the sizes of the different parts of the neo4j graph store",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.monitor.tx",
    "signature": "apoc.monitor.tx() :: (rolledBackTx :: INTEGER?, peakTx :: INTEGER?, lastTxId :: INTEGER?, currentOpenedTx :: INTEGER?, totalOpenedTx :: INTEGER?, totalTx :: INTEGER?)",
    "description": "apoc.monitor.tx() returns informations about the neo4j transaction manager",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.athop",
    "signature": "apoc.neighbors.athop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)",
    "description": "apoc.neighbors.athop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.athop.count",
    "signature": "apoc.neighbors.athop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)",
    "description": "apoc.neighbors.athop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at a distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.byhop",
    "signature": "apoc.neighbors.byhop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (nodes :: LIST? OF NODE?)",
    "description": "apoc.neighbors.byhop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.byhop.count",
    "signature": "apoc.neighbors.byhop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.neighbors.byhop.count(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern at each distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.tohop",
    "signature": "apoc.neighbors.tohop(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (node :: NODE?)",
    "description": "apoc.neighbors.tohop(node, rel-direction-pattern, distance) - returns distinct nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.neighbors.tohop.count",
    "signature": "apoc.neighbors.tohop.count(node :: NODE?, types =  :: STRING?, distance = 1 :: INTEGER?) :: (value :: INTEGER?)",
    "description": "apoc.neighbors.tohop.count(node, rel-direction-pattern, distance) - returns distinct count of nodes of the given relationships in the pattern up to a certain distance, can use '>' or '<' for all outgoing or incoming relationships",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.entities.graph",
    "signature": "apoc.nlp.azure.entities.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)",
    "description": "Creates a (virtual) entity graph for provided text",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.entities.stream",
    "signature": "apoc.nlp.azure.entities.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)",
    "description": "Provides a entity analysis for provided text",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.keyPhrases.graph",
    "signature": "apoc.nlp.azure.keyPhrases.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)",
    "description": "Creates a (virtual) key phrase graph for provided text",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.keyPhrases.stream",
    "signature": "apoc.nlp.azure.keyPhrases.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)",
    "description": "Provides a entity analysis for provided text",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.sentiment.graph",
    "signature": "apoc.nlp.azure.sentiment.graph(source :: ANY?, config = {} :: MAP?) :: (graph :: MAP?)",
    "description": "Creates a (virtual) sentiment graph for provided text",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nlp.azure.sentiment.stream",
    "signature": "apoc.nlp.azure.sentiment.stream(source :: ANY?, config = {} :: MAP?) :: (node :: NODE?, value :: MAP?, error :: MAP?)",
    "description": "Provides a sentiment analysis for provided text",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.collapse",
    "signature": "apoc.nodes.collapse(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (from :: NODE?, rel :: RELATIONSHIP?, to :: NODE?)",
    "description": "apoc.nodes.collapse([nodes...],[{properties:'overwrite' or 'discard' or 'combine'}]) yield from, rel, to merge nodes onto first in list",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.cycles",
    "signature": "apoc.nodes.cycles(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (path :: PATH?)",
    "description": "CALL apoc.nodes.cycles([nodes], $config) - Detect all path cycles from node list",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.delete",
    "signature": "apoc.nodes.delete(nodes :: ANY?, batchSize :: INTEGER?) :: (value :: INTEGER?)",
    "description": "apoc.nodes.delete(node|nodes|id|[ids]) - quickly delete all nodes with these ids",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.get",
    "signature": "apoc.nodes.get(nodes :: ANY?) :: (node :: NODE?)",
    "description": "apoc.nodes.get(node|nodes|id|[ids]) - quickly returns all nodes with these ids",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.group",
    "signature": "apoc.nodes.group(labels :: LIST? OF STRING?, groupByProperties :: LIST? OF STRING?, aggregations = [{*=count}, {*=count}] :: LIST? OF MAP?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?, node :: NODE?, relationship :: RELATIONSHIP?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.link",
    "signature": "apoc.nodes.link(nodes :: LIST? OF NODE?, type :: STRING?, config = {} :: MAP?) :: VOID",
    "description": "apoc.nodes.link([nodes],'REL_TYPE', conf) - creates a linked list of nodes from first to last",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.nodes.rels",
    "signature": "apoc.nodes.rels(relationships :: ANY?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.get.rels(rel|id|[ids]) - quickly returns all relationships with these ids",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.path.expand",
    "signature": "apoc.path.expand(start :: ANY?, relationshipFilter :: STRING?, labelFilter :: STRING?, minLevel :: INTEGER?, maxLevel :: INTEGER?) :: (path :: PATH?)",
    "description": "apoc.path.expand(startNode <id>|Node|list, 'TYPE|TYPE_OUT>|<TYPE_IN', '+YesLabel|-NoLabel', minLevel, maxLevel ) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.path.expandConfig",
    "signature": "apoc.path.expandConfig(start :: ANY?, config :: MAP?) :: (path :: PATH?)",
    "description": "apoc.path.expandConfig(startNode <id>|Node|list, {minLevel,maxLevel,uniqueness,relationshipFilter,labelFilter,uniqueness:'RELATIONSHIP_PATH',bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand from start node following the given relationships from min to max-level adhering to the label filters. ",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.path.spanningTree",
    "signature": "apoc.path.spanningTree(start :: ANY?, config :: MAP?) :: (path :: PATH?)",
    "description": "apoc.path.spanningTree(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield path - expand a spanning tree reachable from start node following relationships to max-level adhering to the label filters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.path.subgraphAll",
    "signature": "apoc.path.subgraphAll(start :: ANY?, config :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.path.subgraphAll(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield nodes, relationships - expand the subgraph reachable from start node following relationships to max-level adhering to the label filters, and also return all relationships within the subgraph",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.path.subgraphNodes",
    "signature": "apoc.path.subgraphNodes(start :: ANY?, config :: MAP?) :: (node :: NODE?)",
    "description": "apoc.path.subgraphNodes(startNode <id>|Node|list, {maxLevel,relationshipFilter,labelFilter,bfs:true, filterStartNode:false, limit:-1, optional:false, endNodes:[], terminatorNodes:[], sequence, beginSequenceAtStart:true}) yield node - expand the subgraph nodes reachable from start node following relationships to max-level adhering to the label filters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.cancel",
    "signature": "apoc.periodic.cancel(name :: STRING?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
    "description": "apoc.periodic.cancel(name) - cancel job with the given name",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.commit",
    "signature": "apoc.periodic.commit(statement :: STRING?, params = {} :: MAP?) :: (updates :: INTEGER?, executions :: INTEGER?, runtime :: INTEGER?, batches :: INTEGER?, failedBatches :: INTEGER?, batchErrors :: MAP?, failedCommits :: INTEGER?, commitErrors :: MAP?, wasTerminated :: BOOLEAN?)",
    "description": "apoc.periodic.commit(statement,params) - runs the given statement in separate transactions until it returns 0",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.countdown",
    "signature": "apoc.periodic.countdown(name :: STRING?, statement :: STRING?, rate :: INTEGER?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
    "description": "apoc.periodic.countdown('name',statement,repeat-rate-in-seconds) submit a repeatedly-called background statement until it returns 0",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.iterate",
    "signature": "apoc.periodic.iterate(cypherIterate :: STRING?, cypherAction :: STRING?, config :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)",
    "description": "apoc.periodic.iterate('statement returning items', 'statement per item', {batchSize:1000,iterateList:true,parallel:false,params:{},concurrency:50,retries:0}) YIELD batches, total - run the second statement for each item returned by the first statement. Returns number of batches and total processed rows",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.list",
    "signature": "apoc.periodic.list() :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
    "description": "apoc.periodic.list - list all jobs",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.repeat",
    "signature": "apoc.periodic.repeat(name :: STRING?, statement :: STRING?, rate :: INTEGER?, config = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
    "description": "apoc.periodic.repeat('name',statement,repeat-rate-in-seconds, config) submit a repeatedly-called background statement. Fourth parameter 'config' is optional and can contain 'params' entry for nested statement.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.rock_n_roll",
    "signature": "apoc.periodic.rock_n_roll(cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, wasTerminated :: BOOLEAN?, failedParams :: MAP?, updateStatistics :: MAP?)",
    "description": "apoc.periodic.rock_n_roll('some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.rock_n_roll_while",
    "signature": "apoc.periodic.rock_n_roll_while(cypherLoop :: STRING?, cypherIterate :: STRING?, cypherAction :: STRING?, batchSize :: INTEGER?) :: (loop :: ANY?, batches :: INTEGER?, total :: INTEGER?)",
    "description": "apoc.periodic.rock_n_roll_while('some cypher for knowing when to stop', 'some cypher for iteration', 'some cypher as action on each iteration', 10000) YIELD batches, total - run the action statement in batches over the iterator statement's results in a separate thread. Returns number of batches and total processed rows",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.submit",
    "signature": "apoc.periodic.submit(name :: STRING?, statement :: STRING?, params = {} :: MAP?) :: (name :: STRING?, delay :: INTEGER?, rate :: INTEGER?, done :: BOOLEAN?, cancelled :: BOOLEAN?)",
    "description": "apoc.periodic.submit('name',statement,params) - submit a one-off background statement; parameter 'params' is optional and can contain query parameters for Cypher statement",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.periodic.truncate",
    "signature": "apoc.periodic.truncate(config = {} :: MAP?) :: VOID",
    "description": "apoc.periodic.truncate({config}) - removes all entities (and optionally indexes and constraints) from db using the apoc.periodic.iterate under the hood",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.append",
    "signature": "apoc.redis.append(uri :: STRING?, key :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.append(uri, key, value, {config}) | Execute the 'APPEND key value' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.configGet",
    "signature": "apoc.redis.configGet(uri :: STRING?, parameter :: STRING?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.redis.configGet(uri, parameter, {config}) | Execute the 'CONFIG GET parameter' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.configSet",
    "signature": "apoc.redis.configSet(uri :: STRING?, parameter :: STRING?, value :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.configSet(uri, parameter, {config}) | Execute the 'CONFIG SET parameter value' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.copy",
    "signature": "apoc.redis.copy(uri :: STRING?, source :: ANY?, destination :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.redis.copy(uri, source, destination, {config}) | Execute the 'COPY source destination' command and returns true if source was copied and false otherwise",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.eval",
    "signature": "apoc.redis.eval(uri :: STRING?, script :: STRING?, outputType :: STRING?, keys :: LIST? OF ANY?, values :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.eval(uri, script, outputType, keys, values, {config}) | Execute the 'EVAL script' command. In the parameters provided to the procedure, keys are bound to the KEYS[n] like special array of the Lua script and values are bound to the ARGV[n] like special array of the Lua script.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.exists",
    "signature": "apoc.redis.exists(uri :: STRING?, keys :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.exists(uri, keys, {config}) | Execute the 'EXISTS keys' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.get",
    "signature": "apoc.redis.get(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.get(uri, key, {config}) | Execute the 'GET key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.getSet",
    "signature": "apoc.redis.getSet(uri :: STRING?, key :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.getSet(uri, key, value, {config}) | Execute the 'SET key value' command and return old value stored (or null if did not exists)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hdel",
    "signature": "apoc.redis.hdel(uri :: STRING?, key :: ANY?, fields :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.hdel(uri, key, fields, {config}) | Execute the 'HDEL key fields' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hexists",
    "signature": "apoc.redis.hexists(uri :: STRING?, key :: ANY?, field :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.redis.hexists(uri, key, field, {config}) | Execute the 'HEXISTS key field' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hget",
    "signature": "apoc.redis.hget(uri :: STRING?, key :: ANY?, field :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.hget(uri, key, field, {config}) | Execute the 'HGET key field' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hgetall",
    "signature": "apoc.redis.hgetall(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.redis.hgetall(uri, key, {config}) | Execute the 'HGETALL key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hincrby",
    "signature": "apoc.redis.hincrby(uri :: STRING?, key :: ANY?, field :: ANY?, amount :: INTEGER?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.hincrby(uri, key, field, amount, {config}) | Execute the 'HINCRBY key field amount' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.hset",
    "signature": "apoc.redis.hset(uri :: STRING?, key :: ANY?, field :: ANY?, value :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.redis.hset(uri, key, field, value, {config}) | Execute the 'HSET key field value' command and returns true if it is a new field in the hash or false if the field already exists",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.incrby",
    "signature": "apoc.redis.incrby(uri :: STRING?, key :: ANY?, amount :: INTEGER?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.incrby(uri, key, amount, {config}) | Execute the 'INCRBY key increment' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.info",
    "signature": "apoc.redis.info(uri :: STRING?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.info(uri, {config}) | Execute the 'INFO' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.lrange",
    "signature": "apoc.redis.lrange(uri :: STRING?, key :: ANY?, start :: INTEGER?, stop :: INTEGER?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.redis.lrange(uri, key, start, stop, {config}) | Execute the 'LRANGE key start stop' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.persist",
    "signature": "apoc.redis.persist(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.redis.persist(uri, key, {config}) | Execute the 'PERSIST key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.pexpire",
    "signature": "apoc.redis.pexpire(uri :: STRING?, key :: ANY?, time :: INTEGER?, isExpireAt :: BOOLEAN?, config = {} :: MAP?) :: (value :: BOOLEAN?)",
    "description": "apoc.redis.pexpire(uri, key, time, isExpireAt {config}) | Execute the 'PEXPIRE key time' command, or the 'PEPXPIREAT' if isExpireAt=true",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.pop",
    "signature": "apoc.redis.pop(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.pop(uri, key, {config}) | Execute the 'LPOP key' command, or the 'RPOP' if config right=true (default)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.pttl",
    "signature": "apoc.redis.pttl(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.pttl(uri, key, {config}) | Execute the 'PTTL key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.push",
    "signature": "apoc.redis.push(uri :: STRING?, key :: ANY?, value :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.push(uri, key, values, {config}) | Execute the 'LPUSH key field values' command, or the 'RPUSH' if config right=true (default)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.sadd",
    "signature": "apoc.redis.sadd(uri :: STRING?, key :: ANY?, members :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.sadd(uri, key, members, {config}) | Execute the 'SADD key members' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.scard",
    "signature": "apoc.redis.scard(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.scard(uri, key, {config}) | Execute the 'SCARD key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.smembers",
    "signature": "apoc.redis.smembers(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.redis.smembers(uri, key, {config}) | Execute the 'SMEMBERS key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.spop",
    "signature": "apoc.redis.spop(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: ANY?)",
    "description": "apoc.redis.spop(uri, key, {config}) | Execute the 'SPOP key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.sunion",
    "signature": "apoc.redis.sunion(uri :: STRING?, keys :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.redis.sunion(uri, keys, {config}) | Execute the 'SUNION keys' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.zadd",
    "signature": "apoc.redis.zadd(uri :: STRING?, key :: ANY?, value :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.zadd(uri, keys, scoresAndMembers, {config}) | Execute the 'ZADD key scoresAndMembers' command, where scoresAndMembers is a list of score,member,score,member,...",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.zcard",
    "signature": "apoc.redis.zcard(uri :: STRING?, key :: ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.zcard(uri, key, {config}) | Execute the 'ZCARD key' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.zrangebyscore",
    "signature": "apoc.redis.zrangebyscore(uri :: STRING?, key :: ANY?, min :: INTEGER?, max :: INTEGER?, config = {} :: MAP?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.redis.zrangebyscore(uri, key, min, max, {config}) | Execute the 'ZRANGEBYSCORE key min max' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.redis.zrem",
    "signature": "apoc.redis.zrem(uri :: STRING?, key :: ANY?, members :: LIST? OF ANY?, config = {} :: MAP?) :: (value :: INTEGER?)",
    "description": "apoc.redis.zrem(uri, key, members, {config}) | Execute the 'ZREM key members' command",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.categorize",
    "signature": "apoc.refactor.categorize(sourceKey :: STRING?, type :: STRING?, outgoing :: BOOLEAN?, label :: STRING?, targetKey :: STRING?, copiedKeys :: LIST? OF STRING?, batchSize :: INTEGER?) :: VOID",
    "description": "apoc.refactor.categorize(sourceKey, type, outgoing, label, targetKey, copiedKeys, batchSize) turn each unique propertyKey into a category node and connect to it",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.cloneNodes",
    "signature": "apoc.refactor.cloneNodes(nodes :: LIST? OF NODE?, withRelationships = false :: BOOLEAN?, skipProperties = [] :: LIST? OF STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
    "description": "apoc.refactor.cloneNodes([node1,node2,...]) clone nodes with their labels and properties",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.cloneNodesWithRelationships",
    "signature": "apoc.refactor.cloneNodesWithRelationships(nodes :: LIST? OF NODE?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
    "description": "apoc.refactor.cloneNodesWithRelationships([node1,node2,...]) clone nodes with their labels, properties and relationships",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.cloneSubgraph",
    "signature": "apoc.refactor.cloneSubgraph(nodes :: LIST? OF NODE?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
    "description": "apoc.refactor.cloneSubgraph([node1,node2,...], [rel1,rel2,...]:[], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the given relationships (will exist between cloned nodes only). If no relationships are provided, all relationships between the given nodes will be cloned. Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.cloneSubgraphFromPaths",
    "signature": "apoc.refactor.cloneSubgraphFromPaths(paths :: LIST? OF PATH?, config = {} :: MAP?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
    "description": "apoc.refactor.cloneSubgraphFromPaths([path1, path2, ...], {standinNodes:[], skipProperties:[]}) YIELD input, output, error | from the subgraph formed from the given paths, clone nodes with their labels and properties (optionally skipping any properties in the skipProperties list via the config map), and clone the relationships (will exist between cloned nodes only). Relationships can be optionally redirected according to standinNodes node pairings (this is a list of list-pairs of nodes), so given a node in the original subgraph (first of the pair), an existing node (second of the pair) can act as a standin for it within the cloned subgraph. Cloned relationships will be redirected to the standin.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.collapseNode",
    "signature": "apoc.refactor.collapseNode(nodes :: ANY?, type :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
    "description": "apoc.refactor.collapseNode([node1,node2],'TYPE') collapse node to relationship, node with one rel becomes self-relationship",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.deleteAndReconnect",
    "signature": "apoc.refactor.deleteAndReconnect(path :: PATH?, nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "apoc.refactor.deleteAndReconnect([pathLinkedList], [nodesToRemove], {config}) - Removes some nodes from a linked list",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.extractNode",
    "signature": "apoc.refactor.extractNode(relationships :: ANY?, labels :: LIST? OF STRING?, outType :: STRING?, inType :: STRING?) :: (input :: INTEGER?, output :: NODE?, error :: STRING?)",
    "description": "apoc.refactor.extractNode([rel1,rel2,...], [labels],'OUT','IN') extract node from relationships",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.from",
    "signature": "apoc.refactor.from(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
    "description": "apoc.refactor.from(rel, startNode) redirect relationship to use new start-node",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.invert",
    "signature": "apoc.refactor.invert(relationship :: RELATIONSHIP?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
    "description": "apoc.refactor.invert(rel) inverts relationship direction",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.mergeNodes",
    "signature": "apoc.refactor.mergeNodes(nodes :: LIST? OF NODE?, config = {} :: MAP?) :: (node :: NODE?)",
    "description": "apoc.refactor.mergeNodes([node1,node2],[{properties:'overwrite' or 'discard' or 'combine'}]) merge nodes onto first in list",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.mergeRelationships",
    "signature": "apoc.refactor.mergeRelationships(rels :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (rel :: RELATIONSHIP?)",
    "description": "apoc.refactor.mergeRelationships([rel1,rel2]) merge relationships onto first in list",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.normalizeAsBoolean",
    "signature": "apoc.refactor.normalizeAsBoolean(entity :: ANY?, propertyKey :: STRING?, true_values :: LIST? OF ANY?, false_values :: LIST? OF ANY?) :: VOID",
    "description": "apoc.refactor.normalizeAsBoolean(entity, propertyKey, true_values, false_values) normalize/convert a property to be boolean",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.rename.label",
    "signature": "apoc.refactor.rename.label(oldLabel :: STRING?, newLabel :: STRING?, nodes = [] :: LIST? OF NODE?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",
    "description": "apoc.refactor.rename.label(oldLabel, newLabel, [nodes]) | rename a label from 'oldLabel' to 'newLabel' for all nodes. If 'nodes' is provided renaming is applied to this set only",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.rename.nodeProperty",
    "signature": "apoc.refactor.rename.nodeProperty(oldName :: STRING?, newName :: STRING?, nodes = [] :: LIST? OF NODE?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",
    "description": "apoc.refactor.rename.nodeProperty(oldName, newName, [nodes], {config}) | rename all node's property from 'oldName' to 'newName'. If 'nodes' is provided renaming is applied to this set only",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.rename.type",
    "signature": "apoc.refactor.rename.type(oldType :: STRING?, newType :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",
    "description": "apoc.refactor.rename.type(oldType, newType, [rels], {config}) | rename all relationships with type 'oldType' to 'newType'. If 'rels' is provided renaming is applied to this set only",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.rename.typeProperty",
    "signature": "apoc.refactor.rename.typeProperty(oldName :: STRING?, newName :: STRING?, rels = [] :: LIST? OF RELATIONSHIP?, config = {} :: MAP?) :: (batches :: INTEGER?, total :: INTEGER?, timeTaken :: INTEGER?, committedOperations :: INTEGER?, failedOperations :: INTEGER?, failedBatches :: INTEGER?, retries :: INTEGER?, errorMessages :: MAP?, batch :: MAP?, operations :: MAP?, constraints :: LIST? OF STRING?, indexes :: LIST? OF STRING?)",
    "description": "apoc.refactor.rename.typeProperty(oldName, newName, [rels], {config}) | rename all relationship's property from 'oldName' to 'newName'. If 'rels' is provided renaming is applied to this set only",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.setType",
    "signature": "apoc.refactor.setType(relationship :: RELATIONSHIP?, newType :: STRING?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
    "description": "apoc.refactor.setType(rel, 'NEW-TYPE') change relationship-type",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.refactor.to",
    "signature": "apoc.refactor.to(relationship :: RELATIONSHIP?, newNode :: NODE?) :: (input :: INTEGER?, output :: RELATIONSHIP?, error :: STRING?)",
    "description": "  apoc.refactor.to(rel, endNode) redirect relationship to use new end-node",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.schema.assert",
    "signature": "apoc.schema.assert(indexes :: MAP?, constraints :: MAP?, dropExisting = true :: BOOLEAN?) :: (label :: ANY?, key :: STRING?, keys :: LIST? OF STRING?, unique :: BOOLEAN?, action :: STRING?)",
    "description": "apoc.schema.assert({indexLabel:[[indexKeys]], ...}, {constraintLabel:[constraintKeys], ...}, dropExisting : true) yield label, key, keys, unique, action - drops all other existing indexes and constraints when `dropExisting` is `true` (default is `true`), and asserts that at the end of the operation the given indexes and unique constraints are there, each label:key pair is considered one constraint/label. Non-constraint indexes can define compound indexes with label:[key1,key2...] pairings.",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.schema.nodes",
    "signature": "apoc.schema.nodes(config = {} :: MAP?) :: (name :: STRING?, label :: ANY?, properties :: LIST? OF STRING?, status :: STRING?, type :: STRING?, failure :: STRING?, populationProgress :: FLOAT?, size :: INTEGER?, valuesSelectivity :: FLOAT?, userDescription :: STRING?)",
    "description": "CALL apoc.schema.nodes([config]) yield name, label, properties, status, type",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.schema.properties.distinct",
    "signature": "apoc.schema.properties.distinct(label :: STRING?, key :: STRING?) :: (value :: LIST? OF ANY?)",
    "description": "apoc.schema.properties.distinct(label, key) - quickly returns all distinct values for a given key",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.schema.properties.distinctCount",
    "signature": "apoc.schema.properties.distinctCount(label =  :: STRING?, key =  :: STRING?) :: (label :: STRING?, key :: STRING?, value :: ANY?, count :: INTEGER?)",
    "description": "apoc.schema.properties.distinctCount([label], [key]) YIELD label, key, value, count - quickly returns all distinct values and counts for a given key",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.schema.relationships",
    "signature": "apoc.schema.relationships(config = {} :: MAP?) :: (name :: STRING?, type :: ANY?, properties :: LIST? OF STRING?, status :: STRING?)",
    "description": "CALL apoc.schema.relationships([config]) yield name, startLabel, type, endLabel, properties, status",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.search.multiSearchReduced",
    "signature": "apoc.search.multiSearchReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
    "description": "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.multiSearchReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.search.node",
    "signature": "apoc.search.node(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",
    "description": "Do a parallel search over multiple indexes returning nodes. usage apoc.search.node( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the DISTINCT Nodes found in the different searches.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.search.nodeAll",
    "signature": "apoc.search.nodeAll(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (node :: NODE?)",
    "description": "Do a parallel search over multiple indexes returning nodes. usage apoc.search.nodeAll( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ) returns all the Nodes found in the different searches.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.search.nodeAllReduced",
    "signature": "apoc.search.nodeAllReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: ANY?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
    "description": "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched property. apoc.search.nodeShortAll( map of label and properties which will be searched upon, operator: EXACT / CONTAINS / STARTS WITH | ENDS WITH / = / <> / < / > ..., value ). All 'hits' are returned.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.search.nodeReduced",
    "signature": "apoc.search.nodeReduced(LabelPropertyMap :: ANY?, operator :: STRING?, value :: STRING?) :: (id :: INTEGER?, labels :: LIST? OF STRING?, values :: MAP?)",
    "description": "Do a parallel search over multiple indexes returning a reduced representation of the nodes found: node id, labels and the searched properties. apoc.search.nodeReduced( map of label and properties which will be searched upon, operator: EXACT | CONTAINS | STARTS WITH | ENDS WITH, searchValue ). Multiple search results for the same node are merged into one record.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.spatial.geocode",
    "signature": "apoc.spatial.geocode(location :: STRING?, maxResults = 100 :: INTEGER?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",
    "description": "apoc.spatial.geocode('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.spatial.geocodeOnce",
    "signature": "apoc.spatial.geocodeOnce(location :: STRING?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",
    "description": "apoc.spatial.geocodeOnce('address') YIELD location, latitude, longitude, description, osmData - look up geographic location of address from a geocoding service (the default one is OpenStreetMap)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.spatial.reverseGeocode",
    "signature": "apoc.spatial.reverseGeocode(latitude :: FLOAT?, longitude :: FLOAT?, quotaException = false :: BOOLEAN?) :: (location :: MAP?, data :: MAP?, latitude :: FLOAT?, longitude :: FLOAT?, description :: STRING?)",
    "description": "apoc.spatial.reverseGeocode(latitude,longitude) YIELD location, latitude, longitude, description - look up address from latitude and longitude from a geocoding service (the default one is OpenStreetMap)",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.spatial.sortByDistance",
    "signature": "apoc.spatial.sortByDistance(paths :: LIST? OF PATH?) :: (path :: PATH?, distance :: FLOAT?)",
    "description": "apoc.spatial.sortByDistance(List<Path>) sort the given paths based on the geo informations (lat/long) in ascending order",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.static.get",
    "signature": "apoc.static.get(key :: STRING?) :: (value :: ANY?)",
    "description": "apoc.static.get(name) - returns statically stored value from config (apoc.static.<key>) or server lifetime storage",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.static.list",
    "signature": "apoc.static.list(prefix :: STRING?) :: (key :: STRING?, value :: ANY?)",
    "description": "apoc.static.list(prefix) - returns statically stored values from config (apoc.static.<prefix>.*) or server lifetime storage",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.static.set",
    "signature": "apoc.static.set(key :: STRING?, value :: ANY?) :: (value :: ANY?)",
    "description": "apoc.static.set(name, value) - stores value under key for server lifetime storage, returns previously stored or configured value",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.stats.degrees",
    "signature": "apoc.stats.degrees(types =  :: STRING?) :: (type :: STRING?, direction :: STRING?, total :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p999 :: INTEGER?, max :: INTEGER?, min :: INTEGER?, mean :: FLOAT?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.systemdb.execute",
    "signature": "apoc.systemdb.execute(DDL commands, either a string or a list of strings :: ANY?, params = {} :: MAP?) :: (row :: MAP?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.systemdb.export.metadata",
    "signature": "apoc.systemdb.export.metadata(config = {} :: MAP?) :: (file :: STRING?, source :: STRING?, format :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, properties :: INTEGER?, time :: INTEGER?, rows :: INTEGER?, batchSize :: INTEGER?, batches :: INTEGER?, done :: BOOLEAN?, data :: ANY?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.systemdb.graph",
    "signature": "apoc.systemdb.graph() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.text.doubleMetaphone",
    "signature": "apoc.text.doubleMetaphone(value :: ANY?) :: (value :: STRING?)",
    "description": "apoc.text.doubleMetaphone(value) yield value - Compute the Double Metaphone phonetic encoding of all words of the text value which can be a single string or a list of strings",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.text.phonetic",
    "signature": "apoc.text.phonetic(value :: ANY?) :: (value :: STRING?)",
    "description": "apoc.text.phonetic(value) yield value - Compute the US_ENGLISH phonetic soundex encoding of all words of the text value which can be a single string or a list of strings",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.text.phoneticDelta",
    "signature": "apoc.text.phoneticDelta(text1 :: STRING?, text2 :: STRING?) :: (phonetic1 :: STRING?, phonetic2 :: STRING?, delta :: INTEGER?)",
    "description": "apoc.text.phoneticDelta(text1, text2) yield phonetic1, phonetic2, delta - Compute the US_ENGLISH soundex character difference between two given strings",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.add",
    "signature": "apoc.trigger.add(name :: STRING?, kernelTransaction :: STRING?, selector :: MAP?, config = {} :: MAP?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "add a trigger kernelTransaction under a name, in the kernelTransaction you can use {createdNodes}, {deletedNodes} etc., the selector is {phase:'before/after/rollback/afterAsync'} returns previous and new trigger information. Takes in an optional configuration.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.list",
    "signature": "apoc.trigger.list() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "list all installed triggers",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.pause",
    "signature": "apoc.trigger.pause(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "CALL apoc.trigger.pause(name) | it pauses the trigger",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.remove",
    "signature": "apoc.trigger.remove(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "remove previously added trigger, returns trigger information",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.removeAll",
    "signature": "apoc.trigger.removeAll() :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "removes all previously added trigger, returns trigger information",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.trigger.resume",
    "signature": "apoc.trigger.resume(name :: STRING?) :: (name :: STRING?, query :: STRING?, selector :: MAP?, params :: MAP?, installed :: BOOLEAN?, paused :: BOOLEAN?)",
    "description": "CALL apoc.trigger.resume(name) | it resumes the paused trigger",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.ttl.expire",
    "signature": "apoc.ttl.expire(node :: NODE?, time :: INTEGER?, timeUnit :: STRING?) :: VOID",
    "description": "CALL apoc.ttl.expire(node,time,'time-unit') - expire node at specified time by setting :TTL label and `ttl` property",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.ttl.expireIn",
    "signature": "apoc.ttl.expireIn(node :: NODE?, timeDelta :: INTEGER?, timeUnit :: STRING?) :: VOID",
    "description": "CALL apoc.ttl.expireIn(node,timeDelta,'time-unit') - expire node after specified length of time time by setting :TTL label and `ttl` property",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.util.sleep",
    "signature": "apoc.util.sleep(duration :: INTEGER?) :: VOID",
    "description": "apoc.util.sleep(<duration>) | sleeps for <duration> millis, transaction termination is honored",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.util.validate",
    "signature": "apoc.util.validate(predicate :: BOOLEAN?, message :: STRING?, params :: LIST? OF ANY?) :: VOID",
    "description": "apoc.util.validate(predicate, message, params) | if the predicate yields to true raise an exception",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.uuid.install",
    "signature": "apoc.uuid.install(label :: STRING?, config = {} :: MAP?) :: (batchComputationResult :: MAP?, label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",
    "description": "CALL apoc.uuid.install(label, {addToExistingNodes: true/false, uuidProperty: 'uuid'}) yield label, installed, properties, batchComputationResult | it will add the uuid transaction handler
for the provided `label` and `uuidProperty`, in case the UUID handler is already present it will be replaced by the new one",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.uuid.list",
    "signature": "apoc.uuid.list() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",
    "description": "CALL apoc.uuid.list() yield label, installed, properties | provides a list of all the uuid handlers installed with the related configuration",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.uuid.remove",
    "signature": "apoc.uuid.remove(label :: STRING?) :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",
    "description": "CALL apoc.uuid.remove(label) yield label, installed, properties | remove previously added uuid handler and returns uuid information. All the existing uuid properties are left as-is",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.uuid.removeAll",
    "signature": "apoc.uuid.removeAll() :: (label :: STRING?, installed :: BOOLEAN?, properties :: MAP?)",
    "description": "CALL apoc.uuid.removeAll() yield label, installed, properties | it removes all previously added uuid handlers and returns uuids information. All the existing uuid properties are left as-is",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.warmup.run",
    "signature": "apoc.warmup.run(loadProperties = false :: BOOLEAN?, loadDynamicProperties = false :: BOOLEAN?, loadIndexes = false :: BOOLEAN?) :: (pageSize :: INTEGER?, totalTime :: INTEGER?, transactionWasTerminated :: BOOLEAN?, nodesPerPage :: INTEGER?, nodesTotal :: INTEGER?, nodePages :: INTEGER?, nodesTime :: INTEGER?, relsPerPage :: INTEGER?, relsTotal :: INTEGER?, relPages :: INTEGER?, relsTime :: INTEGER?, relGroupsPerPage :: INTEGER?, relGroupsTotal :: INTEGER?, relGroupPages :: INTEGER?, relGroupsTime :: INTEGER?, propertiesLoaded :: BOOLEAN?, dynamicPropertiesLoaded :: BOOLEAN?, propsPerPage :: INTEGER?, propRecordsTotal :: INTEGER?, propPages :: INTEGER?, propsTime :: INTEGER?, stringPropsPerPage :: INTEGER?, stringPropRecordsTotal :: INTEGER?, stringPropPages :: INTEGER?, stringPropsTime :: INTEGER?, arrayPropsPerPage :: INTEGER?, arrayPropRecordsTotal :: INTEGER?, arrayPropPages :: INTEGER?, arrayPropsTime :: INTEGER?, indexesLoaded :: BOOLEAN?, indexPages :: INTEGER?, indexTime :: INTEGER?)",
    "description": "apoc.warmup.run(loadProperties=false,loadDynamicProperties=false,loadIndexes=false) - quickly loads all nodes and rels into memory by skipping one page at a time",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.when",
    "signature": "apoc.when(condition :: BOOLEAN?, ifQuery :: STRING?, elseQuery =  :: STRING?, params = {} :: MAP?) :: (value :: MAP?)",
    "description": "apoc.when(condition, ifQuery, elseQuery:'', params:{}) yield value - based on the conditional, executes read-only ifQuery or elseQuery with the given parameters",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "apoc.xml.import",
    "signature": "apoc.xml.import(url :: STRING?, config = {} :: MAP?) :: (node :: NODE?)",
    "description": "Deprecated by apoc.import.xml",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.awaitIndex",
    "signature": "db.awaitIndex(indexName :: STRING?, timeOutSeconds = 300 :: INTEGER?) :: VOID",
    "description": "Wait for an index to come online (for example: CALL db.awaitIndex(\"MyIndex\", 300)).",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.awaitIndexes",
    "signature": "db.awaitIndexes(timeOutSeconds = 300 :: INTEGER?) :: VOID",
    "description": "Wait for all indexes to come online (for example: CALL db.awaitIndexes(300)).",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.checkpoint",
    "signature": "db.checkpoint() :: (success :: BOOLEAN?, message :: STRING?)",
    "description": "Initiate and wait for a new check point, or wait any already on-going check point to complete. Note that this temporarily disables the `dbms.checkpoint.iops.limit` setting in order to make the check point complete faster. This might cause transaction throughput to degrade slightly, due to increased IO load.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.clearQueryCaches",
    "signature": "db.clearQueryCaches() :: (value :: STRING?)",
    "description": "Clears all query caches.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.constraints",
    "signature": "db.constraints() :: (name :: STRING?, description :: STRING?, details :: STRING?)",
    "description": "List all constraints in the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.createIndex",
    "signature": "db.createIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?)",
    "description": "Create a named schema index with specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.createLabel",
    "signature": "db.createLabel(newLabel :: STRING?) :: VOID",
    "description": "Create a label",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.createNodeKey",
    "signature": "db.createNodeKey(constraintName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?)",
    "description": "Create a named node key constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.createProperty",
    "signature": "db.createProperty(newProperty :: STRING?) :: VOID",
    "description": "Create a Property",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.createRelationshipType",
    "signature": "db.createRelationshipType(newRelationshipType :: STRING?) :: VOID",
    "description": "Create a RelationshipType",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.createUniquePropertyConstraint",
    "signature": "db.createUniquePropertyConstraint(constraintName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, providerName :: STRING?, status :: STRING?)",
    "description": "Create a named unique property constraint. Backing index will use specified index provider and configuration (optional). Yield: name, labels, properties, providerName, status",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.index.fulltext.awaitEventuallyConsistentIndexRefresh",
    "signature": "db.index.fulltext.awaitEventuallyConsistentIndexRefresh() :: VOID",
    "description": "Wait for the updates from recently committed transactions to be applied to any eventually-consistent full-text indexes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.index.fulltext.createNodeIndex",
    "signature": "db.index.fulltext.createNodeIndex(indexName :: STRING?, labels :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID",
    "description": "Create a node full-text index for the given labels and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.index.fulltext.createRelationshipIndex",
    "signature": "db.index.fulltext.createRelationshipIndex(indexName :: STRING?, relationshipTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, config = {} :: MAP?) :: VOID",
    "description": "Create a relationship full-text index for the given relationship types and properties. The optional 'config' map parameter can be used to supply settings to the index. Supported settings are 'analyzer', for specifying what analyzer to use when indexing and querying. Use the `db.index.fulltext.listAvailableAnalyzers` procedure to see what options are available. And 'eventually_consistent' which can be set to 'true' to make this index eventually consistent, such that updates from committing transactions are applied in a background thread.",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.index.fulltext.drop",
    "signature": "db.index.fulltext.drop(indexName :: STRING?) :: VOID",
    "description": "Drop the specified index.",
    "mode": "SCHEMA",
    "defaultBuiltInRoles": [
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "db.index.fulltext.listAvailableAnalyzers",
    "signature": "db.index.fulltext.listAvailableAnalyzers() :: (analyzer :: STRING?, description :: STRING?, stopwords :: LIST? OF STRING?)",
    "description": "List the available analyzers that the full-text indexes can be configured with.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.index.fulltext.queryNodes",
    "signature": "db.index.fulltext.queryNodes(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (node :: NODE?, score :: FLOAT?)",
    "description": "Query the given full-text index. Returns the matching nodes, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.index.fulltext.queryRelationships",
    "signature": "db.index.fulltext.queryRelationships(indexName :: STRING?, queryString :: STRING?, options = {} :: MAP?) :: (relationship :: RELATIONSHIP?, score :: FLOAT?)",
    "description": "Query the given full-text index. Returns the matching relationships, and their Lucene query score, ordered by score. Valid keys for the options map are: 'skip' to skip the top N results; 'limit' to limit the number of results returned.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.indexDetails",
    "signature": "db.indexDetails(indexName :: STRING?) :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?, indexConfig :: MAP?, failureMessage :: STRING?)",
    "description": "Detailed description of specific index.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.indexes",
    "signature": "db.indexes() :: (id :: INTEGER?, name :: STRING?, state :: STRING?, populationPercent :: FLOAT?, uniqueness :: STRING?, type :: STRING?, entityType :: STRING?, labelsOrTypes :: LIST? OF STRING?, properties :: LIST? OF STRING?, provider :: STRING?)",
    "description": "List all indexes in the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.info",
    "signature": "db.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?)",
    "description": "Provides information regarding the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.labels",
    "signature": "db.labels() :: (label :: STRING?)",
    "description": "List all available labels in the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.listLocks",
    "signature": "db.listLocks() :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?, transactionId :: STRING?)",
    "description": "List all locks at this database.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.ping",
    "signature": "db.ping() :: (success :: BOOLEAN?)",
    "description": "This procedure can be used by client side tooling to test whether they are correctly connected to a database. The procedure is available in all databases and always returns true. A faulty connection can be detected by not being able to call this procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.prepareForReplanning",
    "signature": "db.prepareForReplanning(timeOutSeconds = 300 :: INTEGER?) :: VOID",
    "description": "Triggers an index resample and waits for it to complete, and after that clears query caches. After this procedure has finished queries will be planned using the latest database statistics.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.propertyKeys",
    "signature": "db.propertyKeys() :: (propertyKey :: STRING?)",
    "description": "List all property keys in the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.relationshipTypes",
    "signature": "db.relationshipTypes() :: (relationshipType :: STRING?)",
    "description": "List all available relationship types in the database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.resampleIndex",
    "signature": "db.resampleIndex(indexName :: STRING?) :: VOID",
    "description": "Schedule resampling of an index (for example: CALL db.resampleIndex(\"MyIndex\")).",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.resampleOutdatedIndexes",
    "signature": "db.resampleOutdatedIndexes() :: VOID",
    "description": "Schedule resampling of all outdated indexes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.schema.nodeTypeProperties",
    "signature": "db.schema.nodeTypeProperties() :: (nodeType :: STRING?, nodeLabels :: LIST? OF STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)",
    "description": "Show the derived property schema of the nodes in tabular form.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.schema.relTypeProperties",
    "signature": "db.schema.relTypeProperties() :: (relType :: STRING?, propertyName :: STRING?, propertyTypes :: LIST? OF STRING?, mandatory :: BOOLEAN?)",
    "description": "Show the derived property schema of the relationships in tabular form.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.schema.visualization",
    "signature": "db.schema.visualization() :: (nodes :: LIST? OF NODE?, relationships :: LIST? OF RELATIONSHIP?)",
    "description": "Visualize the schema of the data.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.schemaStatements",
    "signature": "db.schemaStatements() :: (name :: STRING?, type :: STRING?, createStatement :: STRING?, dropStatement :: STRING?)",
    "description": "List all statements for creating and dropping existing indexes and constraints. Note that only index types introduced before Neo4j 4.3 are included.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.clear",
    "signature": "db.stats.clear(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)",
    "description": "Clear collected data of a given data section. Valid sections are 'QUERIES'",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.collect",
    "signature": "db.stats.collect(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)",
    "description": "Start data collection of a given data section. Valid sections are 'QUERIES'",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.retrieve",
    "signature": "db.stats.retrieve(section :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)",
    "description": "Retrieve statistical data about the current database. Valid sections are 'GRAPH COUNTS', 'TOKENS', 'QUERIES', 'META'",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.retrieveAllAnonymized",
    "signature": "db.stats.retrieveAllAnonymized(graphToken :: STRING?, config = {} :: MAP?) :: (section :: STRING?, data :: MAP?)",
    "description": "Retrieve all available statistical data about the current database, in an anonymized form.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.status",
    "signature": "db.stats.status() :: (section :: STRING?, status :: STRING?, data :: MAP?)",
    "description": "Retrieve the status of all available collector daemons, for this database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "db.stats.stop",
    "signature": "db.stats.stop(section :: STRING?) :: (section :: STRING?, success :: BOOLEAN?, message :: STRING?)",
    "description": "Stop data collection of a given data section. Valid sections are 'QUERIES'",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.cluster.overview",
    "signature": "dbms.cluster.overview() :: (id :: STRING?, addresses :: LIST? OF STRING?, databases :: MAP?, groups :: LIST? OF STRING?)",
    "description": "Overview of all currently accessible cluster members, their databases and roles.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.cluster.protocols",
    "signature": "dbms.cluster.protocols() :: (orientation :: STRING?, remoteAddress :: STRING?, applicationProtocol :: STRING?, applicationProtocolVersion :: INTEGER?, modifierProtocols :: STRING?)",
    "description": "Overview of installed protocols",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.cluster.role",
    "signature": "dbms.cluster.role(database :: STRING?) :: (role :: STRING?)",
    "description": "The role of this instance in the cluster for the specified database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.cluster.routing.getRoutingTable",
    "signature": "dbms.cluster.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?)",
    "description": "Returns endpoints of this instance.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.components",
    "signature": "dbms.components() :: (name :: STRING?, versions :: LIST? OF STRING?, edition :: STRING?)",
    "description": "List DBMS components and their versions.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.database.state",
    "signature": "dbms.database.state(databaseName :: STRING?) :: (role :: STRING?, address :: STRING?, status :: STRING?, error :: STRING?)",
    "description": "The actual status of the database with the provided name on this neo4j instance.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.functions",
    "signature": "dbms.functions() :: (name :: STRING?, signature :: STRING?, category :: STRING?, description :: STRING?, aggregating :: BOOLEAN?, defaultBuiltInRoles :: LIST? OF STRING?)",
    "description": "List all functions in the DBMS.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.info",
    "signature": "dbms.info() :: (id :: STRING?, name :: STRING?, creationDate :: STRING?)",
    "description": "Provides information regarding the DBMS.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killConnection",
    "signature": "dbms.killConnection(id :: STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill network connection with the given connection id.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killConnections",
    "signature": "dbms.killConnections(ids :: LIST? OF STRING?) :: (connectionId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill all network connections with the given connection ids.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killQueries",
    "signature": "dbms.killQueries(ids :: LIST? OF STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill all transactions executing a query with any of the given query ids.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killQuery",
    "signature": "dbms.killQuery(id :: STRING?) :: (queryId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill all transactions executing the query with the given query id.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killTransaction",
    "signature": "dbms.killTransaction(id :: STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill transaction with provided id.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.killTransactions",
    "signature": "dbms.killTransactions(ids :: LIST? OF STRING?) :: (transactionId :: STRING?, username :: STRING?, message :: STRING?)",
    "description": "Kill transactions with provided ids.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listActiveLocks",
    "signature": "dbms.listActiveLocks(queryId :: STRING?) :: (mode :: STRING?, resourceType :: STRING?, resourceId :: INTEGER?)",
    "description": "List the active lock requests granted for the transaction executing the query with the given query id.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listCapabilities",
    "signature": "dbms.listCapabilities() :: (name :: STRING?, description :: STRING?, value :: ANY?)",
    "description": "List capabilities",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listConfig",
    "signature": "dbms.listConfig(searchString =  :: STRING?) :: (name :: STRING?, description :: STRING?, value :: STRING?, dynamic :: BOOLEAN?)",
    "description": "List the currently active config of Neo4j.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listConnections",
    "signature": "dbms.listConnections() :: (connectionId :: STRING?, connectTime :: STRING?, connector :: STRING?, username :: STRING?, userAgent :: STRING?, serverAddress :: STRING?, clientAddress :: STRING?)",
    "description": "List all accepted network connections at this instance that are visible to the user.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listPools",
    "signature": "dbms.listPools() :: (pool :: STRING?, databaseName :: STRING?, heapMemoryUsed :: STRING?, heapMemoryUsedBytes :: STRING?, nativeMemoryUsed :: STRING?, nativeMemoryUsedBytes :: STRING?, freeMemory :: STRING?, freeMemoryBytes :: STRING?, totalPoolMemory :: STRING?, totalPoolMemoryBytes :: STRING?)",
    "description": "List all memory pools, including sub pools, currently registered at this instance that are visible to the user.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listQueries",
    "signature": "dbms.listQueries() :: (queryId :: STRING?, username :: STRING?, metaData :: MAP?, query :: STRING?, parameters :: MAP?, planner :: STRING?, runtime :: STRING?, indexes :: LIST? OF MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, status :: STRING?, resourceInformation :: MAP?, activeLockCount :: INTEGER?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, database :: STRING?, transactionId :: STRING?)",
    "description": "List all queries currently executing at this instance that are visible to the user.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.listTransactions",
    "signature": "dbms.listTransactions() :: (transactionId :: STRING?, username :: STRING?, metaData :: MAP?, startTime :: STRING?, protocol :: STRING?, clientAddress :: STRING?, requestUri :: STRING?, currentQueryId :: STRING?, currentQuery :: STRING?, activeLockCount :: INTEGER?, status :: STRING?, resourceInformation :: MAP?, elapsedTimeMillis :: INTEGER?, cpuTimeMillis :: INTEGER?, waitTimeMillis :: INTEGER?, idleTimeMillis :: INTEGER?, allocatedBytes :: INTEGER?, allocatedDirectBytes :: INTEGER?, pageHits :: INTEGER?, pageFaults :: INTEGER?, connectionId :: STRING?, initializationStackTrace :: STRING?, database :: STRING?, estimatedUsedHeapMemory :: INTEGER?, outerTransactionId :: STRING?, statusDetails :: STRING?)",
    "description": "List all transactions currently executing at this instance that are visible to the user.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.procedures",
    "signature": "dbms.procedures() :: (name :: STRING?, signature :: STRING?, description :: STRING?, mode :: STRING?, defaultBuiltInRoles :: LIST? OF STRING?, worksOnSystem :: BOOLEAN?)",
    "description": "List all procedures in the DBMS.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.quarantineDatabase",
    "signature": "dbms.quarantineDatabase(databaseName :: STRING?, setStatus :: BOOLEAN?, reason = No reason given :: STRING?) :: (databaseName :: STRING?, quarantined :: BOOLEAN?, result :: STRING?)",
    "description": "Place a database into quarantine or remove from it.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.queryJmx",
    "signature": "dbms.queryJmx(query :: STRING?) :: (name :: STRING?, description :: STRING?, attributes :: MAP?)",
    "description": "Query JMX management data by domain and name. For instance, \"*:*\"",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.routing.getRoutingTable",
    "signature": "dbms.routing.getRoutingTable(context :: MAP?, database = null :: STRING?) :: (ttl :: INTEGER?, servers :: LIST? OF MAP?)",
    "description": "Returns endpoints of this instance.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.scheduler.failedJobs",
    "signature": "dbms.scheduler.failedJobs() :: (jobId :: STRING?, group :: STRING?, database :: STRING?, submitter :: STRING?, description :: STRING?, type :: STRING?, submitted :: STRING?, executionStart :: STRING?, failureTime :: STRING?, failureDescription :: STRING?)",
    "description": "List failed job runs. There is a limit for amount of historical data.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.scheduler.groups",
    "signature": "dbms.scheduler.groups() :: (group :: STRING?, threads :: INTEGER?)",
    "description": "List the job groups that are active in the database internal job scheduler.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.scheduler.jobs",
    "signature": "dbms.scheduler.jobs() :: (jobId :: STRING?, group :: STRING?, submitted :: STRING?, database :: STRING?, submitter :: STRING?, description :: STRING?, type :: STRING?, scheduledAt :: STRING?, period :: STRING?, state :: STRING?, currentStateDescription :: STRING?)",
    "description": "List all jobs that are active in the database internal job scheduler.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.scheduler.profile",
    "signature": "dbms.scheduler.profile(method :: STRING?, group :: STRING?, duration :: STRING?) :: (profile :: STRING?)",
    "description": "Begin profiling all threads within the given job group, for the specified duration. Note that profiling incurs overhead to a system, and will slow it down.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.activateUser",
    "signature": "dbms.security.activateUser(username :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
    "description": "Activate a suspended user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.addRoleToUser",
    "signature": "dbms.security.addRoleToUser(roleName :: STRING?, username :: STRING?) :: VOID",
    "description": "Assign a role to the user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.changePassword",
    "signature": "dbms.security.changePassword(password :: STRING?, requirePasswordChange = false :: BOOLEAN?) :: VOID",
    "description": "Change the current user's password.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.changeUserPassword",
    "signature": "dbms.security.changeUserPassword(username :: STRING?, newPassword :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
    "description": "Change the given user's password.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.clearAuthCache",
    "signature": "dbms.security.clearAuthCache() :: VOID",
    "description": "Clears authentication and authorization cache.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.createRole",
    "signature": "dbms.security.createRole(roleName :: STRING?) :: VOID",
    "description": "Create a new role.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.createUser",
    "signature": "dbms.security.createUser(username :: STRING?, password :: STRING?, requirePasswordChange = true :: BOOLEAN?) :: VOID",
    "description": "Create a new user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.deleteRole",
    "signature": "dbms.security.deleteRole(roleName :: STRING?) :: VOID",
    "description": "Delete the specified role. Any role assignments will be removed.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.deleteUser",
    "signature": "dbms.security.deleteUser(username :: STRING?) :: VOID",
    "description": "Delete the specified user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.listRoles",
    "signature": "dbms.security.listRoles() :: (role :: STRING?, users :: LIST? OF STRING?)",
    "description": "List all available roles.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.listRolesForUser",
    "signature": "dbms.security.listRolesForUser(username :: STRING?) :: (value :: STRING?)",
    "description": "List all roles assigned to the specified user.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.listUsers",
    "signature": "dbms.security.listUsers() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)",
    "description": "List all native users.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.listUsersForRole",
    "signature": "dbms.security.listUsersForRole(roleName :: STRING?) :: (value :: STRING?)",
    "description": "List all users currently assigned the specified role.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.removeRoleFromUser",
    "signature": "dbms.security.removeRoleFromUser(roleName :: STRING?, username :: STRING?) :: VOID",
    "description": "Unassign a role from the user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.security.suspendUser",
    "signature": "dbms.security.suspendUser(username :: STRING?) :: VOID",
    "description": "Suspend the specified user.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.setConfigValue",
    "signature": "dbms.setConfigValue(setting :: STRING?, value :: STRING?) :: VOID",
    "description": "Updates a given setting value. Passing an empty value will result in removing the configured value and falling back to the default value. Changes will not persist and will be lost if the server is restarted.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.showCurrentUser",
    "signature": "dbms.showCurrentUser() :: (username :: STRING?, roles :: LIST? OF STRING?, flags :: LIST? OF STRING?)",
    "description": "Show the current user.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.upgrade",
    "signature": "dbms.upgrade() :: (status :: STRING?, upgradeResult :: STRING?)",
    "description": "Upgrade the system database schema if it is not the current schema.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "dbms.upgradeStatus",
    "signature": "dbms.upgradeStatus() :: (status :: STRING?, description :: STRING?, resolution :: STRING?)",
    "description": "Report the current status of the system database sub-graph schema.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "gds.allShortestPaths.delta.mutate",
    "signature": "gds.allShortestPaths.delta.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.delta.mutate.estimate",
    "signature": "gds.allShortestPaths.delta.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.delta.stream",
    "signature": "gds.allShortestPaths.delta.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)",
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.delta.stream.estimate",
    "signature": "gds.allShortestPaths.delta.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.delta.write",
    "signature": "gds.allShortestPaths.delta.write(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Delta Stepping shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph. The computation is run multi-threaded",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.delta.write.estimate",
    "signature": "gds.allShortestPaths.delta.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.mutate",
    "signature": "gds.allShortestPaths.dijkstra.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.mutate.estimate",
    "signature": "gds.allShortestPaths.dijkstra.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.stream",
    "signature": "gds.allShortestPaths.dijkstra.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.stream.estimate",
    "signature": "gds.allShortestPaths.dijkstra.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.write",
    "signature": "gds.allShortestPaths.dijkstra.write(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between one node and any other node in the graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.allShortestPaths.dijkstra.write.estimate",
    "signature": "gds.allShortestPaths.dijkstra.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.allShortestPaths.stream",
    "signature": "gds.alpha.allShortestPaths.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, distance :: FLOAT?)",
    "description": "The All Pairs Shortest Path (APSP) calculates the shortest (weighted) path between all pairs of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.backup",
    "signature": "gds.alpha.backup() :: (graphName :: STRING?, modelName :: STRING?, backupTime :: DATETIME?, exportPath :: STRING?, exportMillis :: INTEGER?, status :: STRING?)",
    "description": "The back-up procedure persists graphs and models to disk",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.closeness.harmonic.stream",
    "signature": "gds.alpha.closeness.harmonic.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, centrality :: FLOAT?)",
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.closeness.harmonic.write",
    "signature": "gds.alpha.closeness.harmonic.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodes :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, writeProperty :: STRING?, centralityDistribution :: MAP?)",
    "description": "Harmonic centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.collapsePath.mutate",
    "signature": "gds.alpha.collapsePath.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGER?, configuration :: MAP?)",
    "description": "Collapse Path algorithm is a traversal algorithm capable of creating relationships between the start and end nodes of a traversal",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.conductance.stream",
    "signature": "gds.alpha.conductance.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (community :: INTEGER?, conductance :: FLOAT?)",
    "description": "Evaluates a division of nodes into communities based on the proportion of relationships that cross community boundaries.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.create.cypherdb",
    "signature": "gds.alpha.create.cypherdb(dbName :: STRING?, graphName :: STRING?) :: (dbName :: STRING?, graphName :: STRING?, createMillis :: INTEGER?)",
    "description": "Creates a database from a GDS graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.mutate",
    "signature": "gds.alpha.hits.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.mutate.estimate",
    "signature": "gds.alpha.hits.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.stats",
    "signature": "gds.alpha.hits.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.stats.estimate",
    "signature": "gds.alpha.hits.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.stream",
    "signature": "gds.alpha.hits.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, values :: MAP?)",
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.stream.estimate",
    "signature": "gds.alpha.hits.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.write",
    "signature": "gds.alpha.hits.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Hyperlink-Induced Topic Search (HITS) is a link analysis algorithm that rates nodes",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.hits.write.estimate",
    "signature": "gds.alpha.hits.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.influenceMaximization.celf.stream",
    "signature": "gds.alpha.influenceMaximization.celf.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, spread :: FLOAT?)",
    "description": "The Cost Effective Lazy Forward (CELF) algorithm aims to find k nodes that maximize the expected spread of influence in the network.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.influenceMaximization.greedy.stream",
    "signature": "gds.alpha.influenceMaximization.greedy.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, spread :: FLOAT?)",
    "description": "The Greedy algorithm aims to find k nodes that maximize the expected spread of influence in the network.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.maxkcut.mutate",
    "signature": "gds.alpha.maxkcut.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, cutCost :: FLOAT?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.maxkcut.mutate.estimate",
    "signature": "gds.alpha.maxkcut.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.maxkcut.stream",
    "signature": "gds.alpha.maxkcut.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)",
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.maxkcut.stream.estimate",
    "signature": "gds.alpha.maxkcut.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Approximate Maximum k-cut maps each node into one of k disjoint communities trying to maximize the sum of weights of relationships between these communities.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.ml.splitRelationships.mutate",
    "signature": "gds.alpha.ml.splitRelationships.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, relationshipsWritten :: INTEGER?, configuration :: MAP?)",
    "description": "Splits a graph into holdout and remaining relationship types and adds them to the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.model.delete",
    "signature": "gds.alpha.model.delete(modelName :: STRING?) :: (modelName :: STRING?, deleteMillis :: INTEGER?)",
    "description": "Deletes a stored model from disk.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.model.load",
    "signature": "gds.alpha.model.load(modelName :: STRING?) :: (modelName :: STRING?, loadMillis :: INTEGER?)",
    "description": "Load a stored model into main memory.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.model.publish",
    "signature": "gds.alpha.model.publish(modelName :: STRING?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)",
    "description": "Make a trained model accessible by all users",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.model.store",
    "signature": "gds.alpha.model.store(modelName :: STRING?, failIfUnsupportedType = true :: BOOLEAN?) :: (modelName :: STRING?, storeMillis :: INTEGER?)",
    "description": "Store the selected model to disk.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.pipeline.linkPrediction.addRandomForest",
    "signature": "gds.alpha.pipeline.linkPrediction.addRandomForest(pipelineName :: STRING?, config :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a random forest configuration to the parameter space of the link prediction train pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.pipeline.nodeClassification.addRandomForest",
    "signature": "gds.alpha.pipeline.nodeClassification.addRandomForest(pipelineName :: STRING?, config :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a random forest configuration to the parameter space of the node classification train pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.restore",
    "signature": "gds.alpha.restore() :: (restoredGraph :: STRING?, restoredModel :: STRING?, status :: STRING?, restoreMillis :: INTEGER?)",
    "description": "The restore procedure reads graphs and models from disk.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.scaleProperties.mutate",
    "signature": "gds.alpha.scaleProperties.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Scale node properties",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.scaleProperties.stream",
    "signature": "gds.alpha.scaleProperties.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, scaledProperty :: LIST? OF FLOAT?)",
    "description": "Scale node properties",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.scc.stream",
    "signature": "gds.alpha.scc.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, componentId :: INTEGER?)",
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.scc.write",
    "signature": "gds.alpha.scc.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, communityCount :: INTEGER?, setCount :: INTEGER?, minSetSize :: INTEGER?, maxSetSize :: INTEGER?, p1 :: INTEGER?, p5 :: INTEGER?, p10 :: INTEGER?, p25 :: INTEGER?, p50 :: INTEGER?, p75 :: INTEGER?, p90 :: INTEGER?, p95 :: INTEGER?, p99 :: INTEGER?, p100 :: INTEGER?, writeProperty :: STRING?)",
    "description": "The SCC algorithm finds sets of connected nodes in an directed graph, where all nodes in the same set form a connected component.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.mutate",
    "signature": "gds.alpha.sllpa.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.mutate.estimate",
    "signature": "gds.alpha.sllpa.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.stats",
    "signature": "gds.alpha.sllpa.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.stats.estimate",
    "signature": "gds.alpha.sllpa.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.stream",
    "signature": "gds.alpha.sllpa.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, values :: MAP?)",
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.stream.estimate",
    "signature": "gds.alpha.sllpa.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.write",
    "signature": "gds.alpha.sllpa.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Speaker Listener Label Propagation algorithm is a fast algorithm for finding overlapping communities in a graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.sllpa.write.estimate",
    "signature": "gds.alpha.sllpa.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.spanningTree.kmax.write",
    "signature": "gds.alpha.spanningTree.kmax.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)",
    "description": "The maximum weight spanning tree (MST) starts from a given node, and finds all its reachable nodes and the set of relationships that connect the nodes together with the maximum possible weight.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.spanningTree.kmin.write",
    "signature": "gds.alpha.spanningTree.kmin.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)",
    "description": "The minimum weight spanning tree (MST) starts from a given node, and finds all its reachable nodes and the set of relationships that connect the nodes together with the minimum possible weight.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.spanningTree.maximum.write",
    "signature": "gds.alpha.spanningTree.maximum.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)",
    "description": "Maximum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is maximized.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.spanningTree.minimum.write",
    "signature": "gds.alpha.spanningTree.minimum.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)",
    "description": "Minimum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is minimized.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.spanningTree.write",
    "signature": "gds.alpha.spanningTree.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, effectiveNodeCount :: INTEGER?)",
    "description": "Minimum weight spanning tree visits all nodes that are in the same connected component as the starting node, and returns a spanning tree of all nodes in the component where the total weight of the relationships is minimized.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.systemMonitor",
    "signature": "gds.alpha.systemMonitor() :: (freeHeap :: INTEGER?, totalHeap :: INTEGER?, maxHeap :: INTEGER?, jvmAvailableCpuCores :: INTEGER?, availableCpuCoresNotRequested :: INTEGER?, jvmHeapStatus :: MAP?, ongoingGdsProcedures :: LIST? OF MAP?)",
    "description": "Get an overview of the system's workload and available resources",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.triangles",
    "signature": "gds.alpha.triangles(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeA :: INTEGER?, nodeB :: INTEGER?, nodeC :: INTEGER?)",
    "description": "Triangles streams the nodeIds of each triangle in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.alpha.userLog",
    "signature": "gds.alpha.userLog(jobId =  :: STRING?) :: (taskName :: STRING?, message :: STRING?, timeStarted :: LOCALTIME?)",
    "description": "Log warnings and hints for currently running tasks.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.mutate",
    "signature": "gds.articleRank.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.mutate.estimate",
    "signature": "gds.articleRank.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.stats",
    "signature": "gds.articleRank.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.stats.estimate",
    "signature": "gds.articleRank.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.stream",
    "signature": "gds.articleRank.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Article Rank is a variant of the Page Rank algorithm, which measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.stream.estimate",
    "signature": "gds.articleRank.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.write",
    "signature": "gds.articleRank.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.articleRank.write.estimate",
    "signature": "gds.articleRank.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.closeness.mutate",
    "signature": "gds.beta.closeness.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateProperty :: STRING?, centralityDistribution :: MAP?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.closeness.stats",
    "signature": "gds.beta.closeness.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.closeness.stream",
    "signature": "gds.beta.closeness.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.closeness.write",
    "signature": "gds.beta.closeness.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, writeProperty :: STRING?, centralityDistribution :: MAP?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Closeness centrality is a way of detecting nodes that are able to spread information very efficiently through a graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graph.export.csv",
    "signature": "gds.beta.graph.export.csv(graphName :: STRING?, configuration = {} :: MAP?) :: (exportName :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, relationshipTypeCount :: INTEGER?, nodePropertyCount :: INTEGER?, relationshipPropertyCount :: INTEGER?, writeMillis :: INTEGER?)",
    "description": "Exports a named graph to CSV files.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graph.export.csv.estimate",
    "signature": "gds.beta.graph.export.csv.estimate(graphName :: STRING?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimate the required disk space for exporting a named graph to CSV files.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graph.generate",
    "signature": "gds.beta.graph.generate(graphName :: STRING?, nodeCount :: INTEGER?, averageDegree :: INTEGER?, configuration = {} :: MAP?) :: (name :: STRING?, nodes :: INTEGER?, relationships :: INTEGER?, generateMillis :: INTEGER?, relationshipSeed :: INTEGER?, averageDegree :: FLOAT?, relationshipDistribution :: ANY?, relationshipProperty :: ANY?)",
    "description": "Computes a random graph, which will be stored in the graph catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graph.project.subgraph",
    "signature": "gds.beta.graph.project.subgraph(graphName :: STRING?, fromGraphName :: STRING?, nodeFilter :: STRING?, relationshipFilter :: STRING?, configuration = {} :: MAP?) :: (fromGraphName :: STRING?, nodeFilter :: STRING?, relationshipFilter :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: INTEGER?)",
    "description": "Creates a named graph in the catalog for use by algorithms.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.mutate",
    "signature": "gds.beta.graphSage.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.mutate.estimate",
    "signature": "gds.beta.graphSage.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.stream",
    "signature": "gds.beta.graphSage.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)",
    "description": "The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.stream.estimate",
    "signature": "gds.beta.graphSage.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.train",
    "signature": "gds.beta.graphSage.train(graphName :: STRING?, configuration = {} :: MAP?) :: (modelInfo :: MAP?, configuration :: MAP?, trainMillis :: INTEGER?)",
    "description": "The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.train.estimate",
    "signature": "gds.beta.graphSage.train.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.write",
    "signature": "gds.beta.graphSage.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The GraphSage algorithm inductively computes embeddings for nodes based on a their features and neighborhoods.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.graphSage.write.estimate",
    "signature": "gds.beta.graphSage.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.mutate",
    "signature": "gds.beta.k1coloring.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)",
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.mutate.estimate",
    "signature": "gds.beta.k1coloring.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.stats",
    "signature": "gds.beta.k1coloring.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)",
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.stats.estimate",
    "signature": "gds.beta.k1coloring.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.stream",
    "signature": "gds.beta.k1coloring.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, color :: INTEGER?)",
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.stream.estimate",
    "signature": "gds.beta.k1coloring.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.write",
    "signature": "gds.beta.k1coloring.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, nodeCount :: INTEGER?, colorCount :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, configuration :: MAP?)",
    "description": "The K-1 Coloring algorithm assigns a color to every node in the graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.k1coloring.write.estimate",
    "signature": "gds.beta.k1coloring.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.listProgress",
    "signature": "gds.beta.listProgress(jobId =  :: STRING?) :: (jobId :: STRING?, taskName :: STRING?, progress :: STRING?, progressBar :: STRING?, status :: STRING?, timeStarted :: LOCALTIME?, elapsedTime :: STRING?)",
    "description": "List progress events for currently running tasks.",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.model.drop",
    "signature": "gds.beta.model.drop(modelName :: STRING?, failIfMissing = true :: BOOLEAN?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)",
    "description": "Drops a loaded model and frees up the resources it occupies.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.model.exists",
    "signature": "gds.beta.model.exists(modelName :: STRING?) :: (modelName :: STRING?, modelType :: STRING?, exists :: BOOLEAN?)",
    "description": "Checks if a given model exists in the model catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.model.list",
    "signature": "gds.beta.model.list(modelName = __NO_VALUE :: STRING?) :: (modelInfo :: MAP?, trainConfig :: MAP?, graphSchema :: MAP?, loaded :: BOOLEAN?, stored :: BOOLEAN?, creationTime :: DATETIME?, shared :: BOOLEAN?)",
    "description": "Lists all models contained in the model catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.mutate",
    "signature": "gds.beta.modularityOptimization.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEGER?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.mutate.estimate",
    "signature": "gds.beta.modularityOptimization.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.stream",
    "signature": "gds.beta.modularityOptimization.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)",
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.stream.estimate",
    "signature": "gds.beta.modularityOptimization.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.write",
    "signature": "gds.beta.modularityOptimization.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodes :: INTEGER?, didConverge :: BOOLEAN?, ranIterations :: INTEGER?, modularity :: FLOAT?, communityCount :: INTEGER?, communityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The Modularity Optimization algorithm groups the nodes in the graph by optimizing the graphs modularity.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.modularityOptimization.write.estimate",
    "signature": "gds.beta.modularityOptimization.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.mutate",
    "signature": "gds.beta.node2vec.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.mutate.estimate",
    "signature": "gds.beta.node2vec.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.stream",
    "signature": "gds.beta.node2vec.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)",
    "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.stream.estimate",
    "signature": "gds.beta.node2vec.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.write",
    "signature": "gds.beta.node2vec.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Node2Vec algorithm computes embeddings for nodes based on random walks.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.node2vec.write.estimate",
    "signature": "gds.beta.node2vec.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.drop",
    "signature": "gds.beta.pipeline.drop(pipelineName :: STRING?, failIfMissing = true :: BOOLEAN?) :: (pipelineInfo :: MAP?, pipelineName :: STRING?, pipelineType :: STRING?, creationTime :: DATETIME?)",
    "description": "Drops a pipeline and frees up the resources it occupies.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.exists",
    "signature": "gds.beta.pipeline.exists(pipelineName :: STRING?) :: (pipelineName :: STRING?, pipelineType :: STRING?, exists :: BOOLEAN?)",
    "description": "Checks if a given pipeline exists in the pipeline catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.addFeature",
    "signature": "gds.beta.pipeline.linkPrediction.addFeature(pipelineName :: STRING?, featureType :: STRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a feature step to an existing link prediction pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.addLogisticRegression",
    "signature": "gds.beta.pipeline.linkPrediction.addLogisticRegression(pipelineName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a logistic regression configuration to the parameter space of the link prediction train pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.addNodeProperty",
    "signature": "gds.beta.pipeline.linkPrediction.addNodeProperty(pipelineName :: STRING?, procedureName :: STRING?, procedureConfiguration :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a node property step to an existing link prediction pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.configureSplit",
    "signature": "gds.beta.pipeline.linkPrediction.configureSplit(pipelineName :: STRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Configures the split of the link prediction pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.create",
    "signature": "gds.beta.pipeline.linkPrediction.create(pipelineName :: STRING?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureSteps :: LIST? OF MAP?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Creates a link prediction pipeline in the model catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.predict.mutate",
    "signature": "gds.beta.pipeline.linkPrediction.predict.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, probabilityDistribution :: MAP?, samplingStats :: MAP?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Predicts relationships for all non-connected node pairs based on a previously trained Link prediction pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.predict.mutate.estimate",
    "signature": "gds.beta.pipeline.linkPrediction.predict.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for predicting classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.predict.stream",
    "signature": "gds.beta.pipeline.linkPrediction.predict.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, probability :: FLOAT?)",
    "description": "Predicts relationships for all node pairs based on a previously trained link prediction model.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.predict.stream.estimate",
    "signature": "gds.beta.pipeline.linkPrediction.predict.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for predicting classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.train",
    "signature": "gds.beta.pipeline.linkPrediction.train(graphName :: STRING?, configuration = {} :: MAP?) :: (modelSelectionStats :: MAP?, trainMillis :: INTEGER?, modelInfo :: MAP?, configuration :: MAP?)",
    "description": "Trains a link prediction model based on a pipeline",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.linkPrediction.train.estimate",
    "signature": "gds.beta.pipeline.linkPrediction.train.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for applying a linkPrediction model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.list",
    "signature": "gds.beta.pipeline.list(pipelineName = __NO_VALUE :: STRING?) :: (pipelineInfo :: MAP?, pipelineName :: STRING?, pipelineType :: STRING?, creationTime :: DATETIME?)",
    "description": "Lists all pipelines contained in the pipeline catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.addLogisticRegression",
    "signature": "gds.beta.pipeline.nodeClassification.addLogisticRegression(pipelineName :: STRING?, config = {} :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a logistic regression configuration to the parameter space of the node classification train pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.addNodeProperty",
    "signature": "gds.beta.pipeline.nodeClassification.addNodeProperty(pipelineName :: STRING?, procedureName :: STRING?, procedureConfiguration :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add a node property step to an existing node classification training pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.configureSplit",
    "signature": "gds.beta.pipeline.nodeClassification.configureSplit(pipelineName :: STRING?, configuration :: MAP?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Configures the split of the node classification training pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.create",
    "signature": "gds.beta.pipeline.nodeClassification.create(pipelineName :: STRING?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Creates a node classification training pipeline in the model catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.mutate",
    "signature": "gds.beta.pipeline.nodeClassification.predict.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Predicts classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.mutate.estimate",
    "signature": "gds.beta.pipeline.nodeClassification.predict.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for predicting classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.stream",
    "signature": "gds.beta.pipeline.nodeClassification.predict.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, predictedClass :: INTEGER?, predictedProbabilities :: LIST? OF FLOAT?)",
    "description": "Predicts classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.stream.estimate",
    "signature": "gds.beta.pipeline.nodeClassification.predict.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for predicting classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.write",
    "signature": "gds.beta.pipeline.nodeClassification.predict.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Predicts classes for all nodes based on a previously trained pipeline model",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.predict.write.estimate",
    "signature": "gds.beta.pipeline.nodeClassification.predict.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for predicting classes for all nodes based on a previously trained pipeline model",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.selectFeatures",
    "signature": "gds.beta.pipeline.nodeClassification.selectFeatures(pipelineName :: STRING?, nodeProperties :: ANY?) :: (name :: STRING?, nodePropertySteps :: LIST? OF MAP?, featureProperties :: LIST? OF STRING?, splitConfig :: MAP?, parameterSpace :: ANY?)",
    "description": "Add one or several features to an existing node classification training pipeline.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.train",
    "signature": "gds.beta.pipeline.nodeClassification.train(graphName :: STRING?, configuration = {} :: MAP?) :: (modelSelectionStats :: MAP?, trainMillis :: INTEGER?, modelInfo :: MAP?, configuration :: MAP?)",
    "description": "Trains a node classification model based on a pipeline",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.pipeline.nodeClassification.train.estimate",
    "signature": "gds.beta.pipeline.nodeClassification.train.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Estimates memory for training a node classification model based on a pipeline",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.randomWalk.stream",
    "signature": "gds.beta.randomWalk.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeIds :: LIST? OF INTEGER?, path :: PATH?)",
    "description": "Random Walk is an algorithm that provides random paths in a graph. It’s similar to how a drunk person traverses a city.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.beta.randomWalk.stream.estimate",
    "signature": "gds.beta.randomWalk.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.mutate",
    "signature": "gds.betweenness.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.mutate.estimate",
    "signature": "gds.betweenness.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.stats",
    "signature": "gds.betweenness.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.stats.estimate",
    "signature": "gds.betweenness.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.stream",
    "signature": "gds.betweenness.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.stream.estimate",
    "signature": "gds.betweenness.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.write",
    "signature": "gds.betweenness.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, writeMillis :: INTEGER?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.betweenness.write.estimate",
    "signature": "gds.betweenness.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Betweenness centrality measures the relative information flow that passes through a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.bfs.mutate",
    "signature": "gds.bfs.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.bfs.mutate.estimate",
    "signature": "gds.bfs.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.bfs.stream",
    "signature": "gds.bfs.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (sourceNode :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)",
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.bfs.stream.estimate",
    "signature": "gds.bfs.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "BFS is a traversal algorithm, which explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.debug.sysInfo",
    "signature": "gds.debug.sysInfo() :: (key :: STRING?, value :: ANY?)",
    "description": "Returns details about the status of the system",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.mutate",
    "signature": "gds.degree.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.mutate.estimate",
    "signature": "gds.degree.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.stats",
    "signature": "gds.degree.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.stats.estimate",
    "signature": "gds.degree.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.stream",
    "signature": "gds.degree.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.stream.estimate",
    "signature": "gds.degree.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.write",
    "signature": "gds.degree.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, centralityDistribution :: MAP?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.degree.write.estimate",
    "signature": "gds.degree.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Degree centrality measures the number of incoming and outgoing relationships from a node.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.dfs.mutate",
    "signature": "gds.dfs.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.dfs.mutate.estimate",
    "signature": "gds.dfs.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.dfs.stream",
    "signature": "gds.dfs.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (sourceNode :: INTEGER?, nodeIds :: LIST? OF INTEGER?, path :: PATH?)",
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.dfs.stream.estimate",
    "signature": "gds.dfs.stream.estimate(graphName :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.mutate",
    "signature": "gds.eigenvector.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.mutate.estimate",
    "signature": "gds.eigenvector.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.stats",
    "signature": "gds.eigenvector.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.stats.estimate",
    "signature": "gds.eigenvector.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.stream",
    "signature": "gds.eigenvector.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.stream.estimate",
    "signature": "gds.eigenvector.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.write",
    "signature": "gds.eigenvector.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Eigenvector Centrality is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.eigenvector.write.estimate",
    "signature": "gds.eigenvector.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.mutate",
    "signature": "gds.fastRP.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (nodePropertiesWritten :: INTEGER?, mutateMillis :: INTEGER?, nodeCount :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.mutate.estimate",
    "signature": "gds.fastRP.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.stats",
    "signature": "gds.fastRP.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.stats.estimate",
    "signature": "gds.fastRP.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.stream",
    "signature": "gds.fastRP.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, embedding :: LIST? OF FLOAT?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.stream.estimate",
    "signature": "gds.fastRP.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.write",
    "signature": "gds.fastRP.write(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeCount :: INTEGER?, nodePropertiesWritten :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.fastRP.write.estimate",
    "signature": "gds.fastRP.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Random Projection produces node embeddings via the fastrp algorithm",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.deleteRelationships",
    "signature": "gds.graph.deleteRelationships(graphName :: STRING?, relationshipType :: STRING?) :: (graphName :: STRING?, relationshipType :: STRING?, deletedRelationships :: INTEGER?, deletedProperties :: MAP?)",
    "description": "Delete the relationship type for a given graph stored in the graph-catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.drop",
    "signature": "gds.graph.drop(graphName :: ANY?, failIfMissing = true :: BOOLEAN?, dbName =  :: STRING?, username =  :: STRING?) :: (graphName :: STRING?, database :: STRING?, memoryUsage :: STRING?, sizeInBytes :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, configuration :: MAP?, density :: FLOAT?, creationTime :: DATETIME?, modificationTime :: DATETIME?, schema :: MAP?)",
    "description": "Drops a named graph from the catalog and frees up the resources it occupies.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.exists",
    "signature": "gds.graph.exists(graphName :: STRING?) :: (graphName :: STRING?, exists :: BOOLEAN?)",
    "description": "Checks if a graph exists in the catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.export",
    "signature": "gds.graph.export(graphName :: STRING?, configuration = {} :: MAP?) :: (dbName :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, relationshipTypeCount :: INTEGER?, nodePropertyCount :: INTEGER?, relationshipPropertyCount :: INTEGER?, writeMillis :: INTEGER?)",
    "description": "Exports a named graph into a new offline Neo4j database.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.list",
    "signature": "gds.graph.list(graphName = __NO_VALUE :: STRING?) :: (degreeDistribution :: MAP?, graphName :: STRING?, database :: STRING?, memoryUsage :: STRING?, sizeInBytes :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, configuration :: MAP?, density :: FLOAT?, creationTime :: DATETIME?, modificationTime :: DATETIME?, schema :: MAP?)",
    "description": "Lists information about named graphs stored in the catalog.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.project",
    "signature": "gds.graph.project(graphName :: STRING?, nodeProjection :: ANY?, relationshipProjection :: ANY?, configuration = {} :: MAP?) :: (nodeProjection :: MAP?, relationshipProjection :: MAP?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: INTEGER?)",
    "description": "Creates a named graph in the catalog for use by algorithms.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.project.cypher",
    "signature": "gds.graph.project.cypher(graphName :: STRING?, nodeQuery :: STRING?, relationshipQuery :: STRING?, configuration = {} :: MAP?) :: (nodeQuery :: STRING?, relationshipQuery :: STRING?, graphName :: STRING?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, projectMillis :: INTEGER?)",
    "description": "Creates a named graph in the catalog for use by algorithms.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.project.cypher.estimate",
    "signature": "gds.graph.project.cypher.estimate(nodeQuery :: STRING?, relationshipQuery :: STRING?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.project.estimate",
    "signature": "gds.graph.project.estimate(nodeProjection :: ANY?, relationshipProjection :: ANY?, configuration = {} :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.removeNodeProperties",
    "signature": "gds.graph.removeNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (graphName :: STRING?, nodeProperties :: LIST? OF STRING?, propertiesRemoved :: INTEGER?)",
    "description": "Removes node properties from a projected graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.streamNodeProperties",
    "signature": "gds.graph.streamNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, nodeProperty :: STRING?, propertyValue :: ANY?)",
    "description": "Streams the given node properties.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.streamNodeProperty",
    "signature": "gds.graph.streamNodeProperty(graphName :: STRING?, nodeProperties :: STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, propertyValue :: ANY?)",
    "description": "Streams the given node property.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.streamRelationshipProperties",
    "signature": "gds.graph.streamRelationshipProperties(graphName :: STRING?, relationshipProperties :: LIST? OF STRING?, relationshipTypes = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, relationshipType :: STRING?, relationshipProperty :: STRING?, propertyValue :: NUMBER?)",
    "description": "Streams the given relationship properties.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.streamRelationshipProperty",
    "signature": "gds.graph.streamRelationshipProperty(graphName :: STRING?, relationshipProperties :: STRING?, relationshipTypes = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (sourceNodeId :: INTEGER?, targetNodeId :: INTEGER?, relationshipType :: STRING?, propertyValue :: NUMBER?)",
    "description": "Streams the given relationship property.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.writeNodeProperties",
    "signature": "gds.graph.writeNodeProperties(graphName :: STRING?, nodeProperties :: LIST? OF STRING?, nodeLabels = [*] :: LIST? OF STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, graphName :: STRING?, nodeProperties :: LIST? OF STRING?, propertiesWritten :: INTEGER?)",
    "description": "Writes the given node properties to an online Neo4j database.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.graph.writeRelationship",
    "signature": "gds.graph.writeRelationship(graphName :: STRING?, relationshipType :: STRING?, relationshipProperty =  :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, graphName :: STRING?, relationshipType :: STRING?, relationshipProperty :: STRING?, relationshipsWritten :: INTEGER?, propertiesWritten :: INTEGER?)",
    "description": "Writes the given relationship and an optional relationship property to an online Neo4j database.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.mutate",
    "signature": "gds.knn.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, nodePairsConsidered :: INTEGER?, didConverge :: BOOLEAN?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.mutate.estimate",
    "signature": "gds.knn.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.stats",
    "signature": "gds.knn.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, nodePairsConsidered :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.stats.estimate",
    "signature": "gds.knn.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.stream",
    "signature": "gds.knn.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)",
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.stream.estimate",
    "signature": "gds.knn.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.write",
    "signature": "gds.knn.write(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, nodePairsConsidered :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The k-nearest neighbor graph algorithm constructs relationships between nodes if the distance between two nodes is among the k nearest distances compared to other nodes.KNN computes distances based on the similarity of node properties",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.knn.write.estimate",
    "signature": "gds.knn.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.mutate",
    "signature": "gds.labelPropagation.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.mutate.estimate",
    "signature": "gds.labelPropagation.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.stats",
    "signature": "gds.labelPropagation.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.stats.estimate",
    "signature": "gds.labelPropagation.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.stream",
    "signature": "gds.labelPropagation.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?)",
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.stream.estimate",
    "signature": "gds.labelPropagation.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.write",
    "signature": "gds.labelPropagation.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Label Propagation algorithm is a fast algorithm for finding communities in a graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.labelPropagation.write.estimate",
    "signature": "gds.labelPropagation.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.list",
    "signature": "gds.list(name =  :: STRING?) :: (name :: STRING?, description :: STRING?, signature :: STRING?, type :: STRING?)",
    "description": "CALL gds.list - lists all algorithm procedures, their description and signature",
    "mode": "DEFAULT",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.mutate",
    "signature": "gds.localClusteringCoefficient.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.mutate.estimate",
    "signature": "gds.localClusteringCoefficient.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.stats",
    "signature": "gds.localClusteringCoefficient.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.stats.estimate",
    "signature": "gds.localClusteringCoefficient.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.stream",
    "signature": "gds.localClusteringCoefficient.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, localClusteringCoefficient :: FLOAT?)",
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.stream.estimate",
    "signature": "gds.localClusteringCoefficient.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.write",
    "signature": "gds.localClusteringCoefficient.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, averageClusteringCoefficient :: FLOAT?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The local clustering coefficient is a metric quantifying how connected the neighborhood of a node is.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.localClusteringCoefficient.write.estimate",
    "signature": "gds.localClusteringCoefficient.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.mutate",
    "signature": "gds.louvain.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.mutate.estimate",
    "signature": "gds.louvain.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.stats",
    "signature": "gds.louvain.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.stats.estimate",
    "signature": "gds.louvain.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.stream",
    "signature": "gds.louvain.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, communityId :: INTEGER?, intermediateCommunityIds :: LIST? OF INTEGER?)",
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.stream.estimate",
    "signature": "gds.louvain.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.write",
    "signature": "gds.louvain.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, modularity :: FLOAT?, modularities :: LIST? OF FLOAT?, ranLevels :: INTEGER?, communityCount :: INTEGER?, communityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Louvain method for community detection is an algorithm for detecting communities in networks.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.louvain.write.estimate",
    "signature": "gds.louvain.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.mutate",
    "signature": "gds.nodeSimilarity.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.mutate.estimate",
    "signature": "gds.nodeSimilarity.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.stats",
    "signature": "gds.nodeSimilarity.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, similarityPairs :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.stats.estimate",
    "signature": "gds.nodeSimilarity.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.stream",
    "signature": "gds.nodeSimilarity.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (node1 :: INTEGER?, node2 :: INTEGER?, similarity :: FLOAT?)",
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.stream.estimate",
    "signature": "gds.nodeSimilarity.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.write",
    "signature": "gds.nodeSimilarity.write(graphName :: STRING?, configuration = {} :: MAP?) :: (preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, nodesCompared :: INTEGER?, relationshipsWritten :: INTEGER?, similarityDistribution :: MAP?, configuration :: MAP?)",
    "description": "The Node Similarity algorithm compares a set of nodes based on the nodes they are connected to. Two nodes are considered similar if they share many of the same neighbors. Node Similarity computes pair-wise similarities based on the Jaccard metric.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.nodeSimilarity.write.estimate",
    "signature": "gds.nodeSimilarity.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.mutate",
    "signature": "gds.pageRank.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.mutate.estimate",
    "signature": "gds.pageRank.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.stats",
    "signature": "gds.pageRank.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.stats.estimate",
    "signature": "gds.pageRank.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.stream",
    "signature": "gds.pageRank.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, score :: FLOAT?)",
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.stream.estimate",
    "signature": "gds.pageRank.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.write",
    "signature": "gds.pageRank.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, ranIterations :: INTEGER?, didConverge :: BOOLEAN?, centralityDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Page Rank is an algorithm that measures the transitive influence or connectivity of nodes.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.pageRank.write.estimate",
    "signature": "gds.pageRank.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.mutate",
    "signature": "gds.shortestPath.astar.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.mutate.estimate",
    "signature": "gds.shortestPath.astar.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.stream",
    "signature": "gds.shortestPath.astar.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)",
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.stream.estimate",
    "signature": "gds.shortestPath.astar.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.write",
    "signature": "gds.shortestPath.astar.write(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The A* shortest path algorithm computes the shortest path between a pair of nodes. It uses the relationship weight property to compare path lengths. In addition, this implementation uses the haversine distance as a heuristic to converge faster.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.astar.write.estimate",
    "signature": "gds.shortestPath.astar.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.mutate",
    "signature": "gds.shortestPath.dijkstra.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.mutate.estimate",
    "signature": "gds.shortestPath.dijkstra.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.stream",
    "signature": "gds.shortestPath.dijkstra.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.stream.estimate",
    "signature": "gds.shortestPath.dijkstra.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.write",
    "signature": "gds.shortestPath.dijkstra.write(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Dijkstra shortest path algorithm computes the shortest (weighted) path between a pair of nodes.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.dijkstra.write.estimate",
    "signature": "gds.shortestPath.dijkstra.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.mutate",
    "signature": "gds.shortestPath.yens.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, mutateMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.mutate.estimate",
    "signature": "gds.shortestPath.yens.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.stream",
    "signature": "gds.shortestPath.yens.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (index :: INTEGER?, sourceNode :: INTEGER?, targetNode :: INTEGER?, totalCost :: FLOAT?, nodeIds :: LIST? OF INTEGER?, costs :: LIST? OF FLOAT?, path :: PATH?)",
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.stream.estimate",
    "signature": "gds.shortestPath.yens.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.write",
    "signature": "gds.shortestPath.yens.write(graphName :: STRING?, configuration = {} :: MAP?) :: (relationshipsWritten :: INTEGER?, writeMillis :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The Yen's shortest path algorithm computes the k shortest (weighted) paths between a pair of nodes.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.shortestPath.yens.write.estimate",
    "signature": "gds.shortestPath.yens.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.mutate",
    "signature": "gds.triangleCount.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.mutate.estimate",
    "signature": "gds.triangleCount.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.stats",
    "signature": "gds.triangleCount.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.stats.estimate",
    "signature": "gds.triangleCount.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.stream",
    "signature": "gds.triangleCount.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, triangleCount :: INTEGER?)",
    "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.stream.estimate",
    "signature": "gds.triangleCount.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.write",
    "signature": "gds.triangleCount.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, globalTriangleCount :: INTEGER?, nodeCount :: INTEGER?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.triangleCount.write.estimate",
    "signature": "gds.triangleCount.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Triangle counting is a community detection graph algorithm that is used to determine the number of triangles passing through each node in the graph.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.mutate",
    "signature": "gds.wcc.mutate(graphName :: STRING?, configuration = {} :: MAP?) :: (mutateMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.mutate.estimate",
    "signature": "gds.wcc.mutate.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.stats",
    "signature": "gds.wcc.stats(graphName :: STRING?, configuration = {} :: MAP?) :: (componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "Executes the algorithm and returns result statistics without writing the result to Neo4j.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.stats.estimate",
    "signature": "gds.wcc.stats.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.stream",
    "signature": "gds.wcc.stream(graphName :: STRING?, configuration = {} :: MAP?) :: (nodeId :: INTEGER?, componentId :: INTEGER?)",
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.stream.estimate",
    "signature": "gds.wcc.stream.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.write",
    "signature": "gds.wcc.write(graphName :: STRING?, configuration = {} :: MAP?) :: (writeMillis :: INTEGER?, nodePropertiesWritten :: INTEGER?, componentCount :: INTEGER?, componentDistribution :: MAP?, postProcessingMillis :: INTEGER?, preProcessingMillis :: INTEGER?, computeMillis :: INTEGER?, configuration :: MAP?)",
    "description": "The WCC algorithm finds sets of connected nodes in an undirected graph, where all nodes in the same set form a connected component.",
    "mode": "WRITE",
    "defaultBuiltInRoles": [
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "gds.wcc.write.estimate",
    "signature": "gds.wcc.write.estimate(graphNameOrConfiguration :: ANY?, algoConfiguration :: MAP?) :: (requiredMemory :: STRING?, treeView :: STRING?, mapView :: MAP?, bytesMin :: INTEGER?, bytesMax :: INTEGER?, nodeCount :: INTEGER?, relationshipCount :: INTEGER?, heapPercentageMin :: FLOAT?, heapPercentageMax :: FLOAT?)",
    "description": "Returns an estimation of the memory consumption for that procedure.",
    "mode": "READ",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "jwt.security.requestAccess",
    "signature": "jwt.security.requestAccess(application :: STRING?) :: (token :: STRING?)",
    "description": "",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  },
  {
    "name": "tx.getMetaData",
    "signature": "tx.getMetaData() :: (metadata :: MAP?)",
    "description": "Provides attached transaction metadata.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": true
  },
  {
    "name": "tx.setMetaData",
    "signature": "tx.setMetaData(data :: MAP?) :: VOID",
    "description": "Attaches a map of data to the transaction. The data will be printed when listing queries, and inserted into the query log.",
    "mode": "DBMS",
    "defaultBuiltInRoles": [
      "reader",
      "editor",
      "publisher",
      "architect",
      "admin"
    ],
    "worksOnSystem": false
  }
]